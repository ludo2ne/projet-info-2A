\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{multirow}
\usepackage{amsmath,amssymb}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{awesomebox}
\usepackage{tcolorbox}
\usepackage{xcolor}
\usepackage{pifont}
\usepackage[top=1.5cm,bottom=1.5cm,margin=2.5cm]{geometry}


\graphicspath{{Images/}} %le chemin vers les images

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}


%-------------------------------------------------------------------------------
% Page de garde
%-------------------------------------------------------------------------------

\begin{titlepage}
\begin{center}


\textsc{{\LARGE Ecole nationale de la statistique \\et de l'analyse de l'information}} \\ %Nom de l'école
\vspace{5mm}
\includegraphics[width=0.4\textwidth]{ensai_logo}\\[2 cm] %logo de l'école

%\textsc{\LARGE Projet de traitement de données }\\[0.5cm] % Nom de cours


% Title
\HRule \\[0.4cm]
{ \huge \bfseries Projet informatique \\ \ \\ Dossier d'analyse}\\[0.4cm]

\HRule \\[1cm]

{\Large 2ème Année}\\ [2cm]

% Auteur(s) et Superviseur(s)

\begin{flushleft} \Large
\emph{Etudiants :}\\
Ludovic \textsc{Deneuville} \\
Jean-François \textsc{Parriaud} \\
Jason \textsc{Torres} \\
Hugo \textsc{Wispelaere} \\
Banruo \textsc{Zhang} \\
\end{flushleft}

\begin{flushright} \Large
\emph{Professeur:} \\
Rémi \textsc{Pépin} \\
\emph{Encadrant:} \\
Cyriel \textsc{Mallart} \\
\end{flushright}


\vfill
{\large 2022 - 2023}
\end{center}
\end{titlepage} 


%-------------------------------------------------------------------------------
% Table des matieres
%-------------------------------------------------------------------------------

\renewcommand{\contentsname}{Sommaire}
\tableofcontents
\newpage


%-------------------------------------------------------------------------------
% Introduction
%-------------------------------------------------------------------------------

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

Les participants à un événement se divisent en deux catégories: les intervenants et le public. Dans le cadre d'une conférence, le nombre d'intervenants (les conférenciers) est fixé par avance et n'est pas destiné à évoluer, sauf cas de force majeure. Le nombre de personnes dans le public (l'auditoire) se gère de façon relativement linéaire (inscriptions, désistements éventuels). Il est indépendant du nombre d'intervenants et il n'est pas nécessaire de gérer sa répartition.\\

L'organisation d'une convention est différente. En effet les intervenants ne sont pas engagés mais volontaires. Ils doivent pouvoir s'inscrire ou se désister librement et chaque intervenant a la charge de quelques membres du public. Par conséquent, le public ne peut s'inscrire qu'à condition qu'il y ait des intervenants pour les encadrer, ce qui signifie qu'il faut pouvoir gérer son effectif et sa répartition. Le but de notre application est de faciliter l'organisation d'une telle convention. \\



\newpage

%-------------------------------------------------------------------------------
% Section 1
%-------------------------------------------------------------------------------

\section{Analyse du besoin}

\subsection{Cahier des charges}

L'objectif de ce projet est de développer une application qui permette de gérer le placement des joueurs d'une conférence de jeux de rôles. Cette application devra être utilisable aussi bien par les organisateurs que par les intervenants et le public.  \\

La convention que notre application doit permettre de gérer se déroule sur un week-end et comporte quatre plages horaires, chacune correspondant à une demi-journée. Elle est dédiée aux jeux de rôle, aussi les intervenants seront par la suite appelés «~Maîtres du Jeu~» ou MJ. Le public venant quant à lui pour jouer, ses membres seront appelés «~Joueurs~».\\ 

L'application permettra à quiconque le souhaite de s'inscrire en tant que Joueur. Les Joueurs auront accès à plusieurs fonctionnalités. La première d'entre elles sera la création de personnages, dans une limite de trois. Un appel l'API suivante \textcolor{blue}{\href{https://www.dnd5eapi.co/}{https://www.dnd5eapi.co/}} permettra de compléter les informations sur les personnages. La détention de personnages permettra au Joueur de s'asseoir à une table par demi-journée. Afin de pouvoir faire un choix éclairé, les Joueurs pourront visualiser, pour chaque table ouverte et disponible, le scénario proposé et ainsi choisir le personnage adéquat. Les Joueurs pourront aussi visualiser un sommaire de leur participation et, le cas échéant, se désister d'une table, ce qui sera automatiquement notifié aux organisateurs.\\

L'application permettra aux Joueurs le désirant de s'inscrire en tant que Maîtres du Jeu. Ceux-ci auront la possibilité, pour chaque demi-journée, de choisir une table.  Ils en définiront le scénario proposé, offrant ainsi à quatre Joueurs la possibilité de s'y inscrire. Ils pourront aussi visualiser les profils des Joueurs inscrits à leur table, afin de mieux préparer leur intervention. En outre, ils auront la possibilité de voir un sommaire de leur participation. Enfin, si nécessaire, ils pourront se désister, entraînant une notification aux organisateurs. Les organisateurs auront alors la charge d'affecter les Joueurs à une autre table dans la mesure du possible, ou d'annuler leur participation à cette demi-journée si nécessaire.\\

\indent Il a été envisagé de différencier totalement les profils Joueur et Maître du Jeu, en leur attribuant des comptes séparés pour une même personne physique. Cela présentait deux inconvénients:
\begin{itemize}
\item{compliquer la gestion des erreurs humaines. En effet, une même personne ne peut pas physiquement participer à deux tables en même temps. Pour chaque compte nous pourrons avoir accès à une liste des tables auxquelles la personne participe. Avoir les comptes Joueur et Maître du Jeu joints signifie la présence d'une unique liste de tables à vérifier. Des comptes séparés auraient entraîné la création de deux listes séparées et, par conséquent, la nécessité de systématiquement vérifier si un compte Maître du Jeu est détenu par une personne ayant aussi un compte Joueur et vice-versa.}
\item{compliquer l'utilisation de l'application pour une personne désirant être à la fois Maître du Jeu et Joueur. En effet, cette personne aurait dû systématiquement se déconnecter et s'authentifier pour passer d'un compte à l'autre.\\}
\end{itemize}

Enfin, les organisateurs auront un profil spécifique, permettant de visualiser un sommaire global de l'activité sur la convention. L'envoi automatique de notifications lors de désistements de Joueurs ou de Maîtres du Jeu leur permettra d'être toujours avertis des changements intervenus. Ils seront en mesure de modifier ou supprimer la participation d'un Maître du jeu ou d'un Joueur, entraînant une notification aux personnes concernées.\\

Un système sommaire d'accès par identifiant sera mis en place, par souci de simplicité. Il permettra à la fois de différencier les statuts des protagonistes et de cloisonner les profils individuels. Il sera toujours possible par la suite de mettre en place un système plus sécurisé avec mot de passe. \\



\subsection{Fonctionnalités attendues}

Le diagramme de cas d'utilisation est montré ci-après en figure \ref{UML_classe_pipeline}. \\

On désigne par «~Utilisateur~» toute personne lançant l'application. Un Utilisateur, lorsqu'il lance le programme a trois actions à sa disposition~:
\begin{itemize}
    \item{S'inscrire~: l'Utilisateur peut se créer un compte Joueur. Il devra alors donner quelques renseignements sur son identité (nom, prénom, mail, pseudo...) avant de se voir attribuer un identifiant.}
    \item{S'authentifier~: Si l'Utilisateur possède déjà un compte avec un profil Joueur ou Organisateur, il devra indiquer son pseudo pour avoir accès aux fonctionnalités liées à son profil. Dans le cadre de ce projet aucun mot de passe n'est nécessaire pour se connecter.}
    \item{Quitter~:  Fermer l'application.\\}
\end{itemize}

Les organisateurs ont le choix entre les six actions suivantes~:
\begin{itemize}
    \item {Déplacer joueur~: lorsque plusieurs tables comptent un trop faible nombre de Joueurs, ou lorsqu'un Maître du Jeu s'est désisté, l'organisateur peut placer les Joueurs sur d'autres tables ou annuler leur participation sur la plage horaire concernée. Dans ce cas, le Joueur est notifié de ce changement par un message qui s'affichera lors de sa prochaine connexion.}
    \item{Déplacer MJ~: dans le même cas de figure, l'organisateur peut placer un Maître du Jeu sur une autre table ou annuler sa participation sur la plage horaire concernée. Dans ce cas, le Maître du Jeu est notifié de ce changement par un message qui s'affichera lors de sa prochaine connexion.}
    \item{Supprimer joueur~: les organisateurs ont la possibilité de supprimer le compte d'un Joueur en cas de comportement inapproprié.}
    \item{Ajouter/supprimer table~: si de nombreuses tables sont complètes, les organisateurs ont la possibilité de créer de nouvelles tables. À l'inverse ils peuvent supprimer une table. Pour être supprimée, une table doit être vide, c'est-à-dire que les organisateurs doivent déplacer au préalable les Joueurs et le Maître du Jeu assis à cette table.}
    \item{Voir programme complet~: l'organisateur peut visualiser sur l'ensemble de la conférence la liste de toutes les tables, avec le scénario, les identités du Maître du Jeu et des Joueurs.}
    \item{Se déconnecter~: l'organisateur met fin à sa session et redevient Utilisateur du point de vue de l'application.\\}
\end{itemize}

Les Joueurs ont le choix entre six actions~:
\begin{itemize}
    \item {Se déconnecter~: le Joueur met fin à sa session et redevient Utilisateur du point de vue de l'application.}
    \item{Voir messages~: le Joueur a accès aux notifications qui lui ont été envoyées. Par exemple celles qui concernent un changement sur son emploi du temps.}
    \item{Créer/supprimer personnage~: le Joueur peut créer un personnage via l'API mentionnée précédemment. Il peut aussi supprimer ce personnage dans la base de données.}
    \item{Rejoindre/quitter table~: le Joueur peut choisir de participer à une table de jeu. Il pourra alors visualiser les tables ouvertes par les Maîtres du Jeu et les scénarios proposés et indiquera le personnage qu'il incarnera sur cette table. Il peut aussi quitter une table sur laquelle il s'était auparavant inscrit.}
    \item{Voir programme~: le Joueur peut visualiser toutes les tables de jeu auxquelles il participe, sur l'ensemble de la conférence.}
    \item{Devenir maître du jeu: le Joueur peut s'inscrire en tant que Maître du Jeu.\\}
\end{itemize}

Un Joueur inscrit comme Maître du Jeu accède à trois fonctionnalités supplémentaires:
\begin{itemize}
    \item{Gérer une table~: il pourra voir les tables disponibles mais non ouvertes par un autre Maître du Jeu, en choisir une, et indiquer le scénario qu'il prévoit pour cette table, avec éventuellement des recommandations concernant les niveaux des personnages des Joueurs.}
    \item{Résilier une table~: il peut également décider que de plus officier en tant que Maître du jeu d'une table.}
    \item{Voir joueurs d'une table~: il aura accès aux informations concernant les Joueurs des tables sur lesquelles il officie, ainsi que leurs personnages.\\}
\end{itemize}

\begin{figure}[H]
    \caption{\textbf{Diagramme de cas d'utilisation}}
    \label{UML_classe_pipeline}
    \centering
    \includegraphics[height=0.9\textheight]{UML_diagrammes/diag_cas_utilisation.png}
\end{figure}


\subsection{Organisation d'équipe}

Lors du démarrage de notre projet, nous avons évoqué plusieurs sujets importants pour une organisation d'équipe efficace et une bonne entente. Le premier sujet évoqué concerne les règles de vie dans notre équipe. Chacun des membres devra respecter les autres, communiquer, être solidaire, être force de proposition, anticiper et ne pas travailler à la dernière minute.


\bigbreak

Ensuite nous avons parlé de la liste de nos compétences et appétences par rapport aux besoins sur ce projet (connaissances en informatique, python, base de données, rédaction...). Ainsi nous nous sommes répartis les rôles suivants:
\begin{itemize}
    \item{Chef de projet~: suivi du projet, organisation, vérification que chacun sait ce qu’il doit faire}
    \item{Responsable de la communication~: s'occupe de la communication avec les intervenants externes}
    \item{Maître du temps~: s’assure que les délais sont bien respectés}
    \item{Expert technique~: assiste les développeurs en cas de problème technique}
    \item{Rédacteur en chef~: Valide les rapports, s'occupe de la mise en forme, corrige les fautes}
\end{itemize}

Nous avons également convenu que tous les membres de l'équipe participeront au développement du code.

\bigbreak

Nous utiliserons ces outils pour répondre à des besoins concernant différents aspects de ce projet :
\begin{itemize}
    \item{Suivi et communication~: \href{https://hackmd.io/CMTCDVW6Spe2PHXOhdKTRQ}{hackMd}, Discord}
    \item{Analyse et Rédaction~: PlantUML, LateX}
    \item{Développement~: langage Python, Visual Studio Code, bdd PostgreSQL, DBeaver, fastApi}
    \item{Gestion de version~: Git, GitHub}
\end{itemize}


\bigbreak

Le diagramme de Gantt relatif à l'organisation de notre équipe est montré en figure \ref{UML_gantt}.\\

La première strate concerne les Livrables, c-a-d les échéances à respecter. Par exemple, le présent dossier d'analyse est à rendre le 8 Octobre.\\

La seconde strate concerne les Rendez-Vous, qui incluent les séances supervisées et les réunions in situ, nommées "Team meeting". Ces dernières permettent de faire le point entre nous sur des tâches clés qui auront un fort impact sur le développement de l'application après que chacun ait pris le temps d'y réfléchir séparément. Elles dépendent de l'avancement du projet et sont fixées à courte échéance. Entre temps, la communication du groupe s'opère via la plate-forme Discord, sur laquelle un serveur dédié à notre projet a été mis en place.\\

\begin{figure}[H]
    \caption{\textbf{Diagramme de Gantt}}
    \label{UML_gantt}
    \centering
    \includegraphics[height=0.5\textheight]{UML_diagrammes/diag_gantt.png}
\end{figure}

La troisième strate illustre les différentes phases du projet. Les six premières semaines sont consacrées à l'étude et à la conception du projet, incluant la réalisation des diagrammes présentés dans ce dossier et la documentation. Pendant ce temps, les cours et TP nécessaires à la réalisation concrète de l'application (Programmation Orientée Objet, Webservices, Git) peuvent avoir lieu. La phase de développement, incluant le codage de l'application et la mise en place de la base de données, se déroulera ensuite sur une période d'environ six semaines. Lorsque cette phase sera bien avancée, la rédaction d'un rapport final pourra débuter, suivie par la préparation de la présentation de notre travail lors de la soutenance.\\

La dernière strate montre les tâches concrètes à réaliser et est complétée au fur et à mesure.\\





%-------------------------------------------------------------------------------
% Section 2
%-------------------------------------------------------------------------------

\newpage
\section{Conception}

\subsection{Modélisation}

L'application sera découpée en trois couches :
\begin{itemize}
    \item \texttt{Couche de Vue} : elle contiendra les classes qui gèrent l'interface avec l'utilisateur,
    \item \texttt{Couche de Service} : elle regroupe les classes qui contiennent les procédures métier,
    \item \texttt{Couche DAO} : ensemble de classes permettant d'accéder à la base de données.
\end{itemize}

\bigbreak

Les objets métier seront regroupés dans un package nommé business\_objects.

\subsection{La couche Vue}

Les classes de la couche vue sont des classes d'interface avec l'utilisateur. Elles affichent les fonctionnalités disponibles. La modélisation de ces classes est ainsi semblable au diagramme de cas d'utilisation présenté précédemment.

\bigbreak

Lorsque l'application se lance, l'utilisateur va être dirigé vers la vue \texttt{AccueilVue}, et va voir les fonctions suivantes :
\begin{itemize}[label=\ding{109}, font=\small]
    \item \texttt{creer\_joueur()}~: la création d'un compte de Joueur passe par la saisie du prénom, du nom, du pseudo et de l'email.
    \item \texttt{se\_connecter()}~: la connexion s'effectue en saisissant le pseudo.
    \item \texttt{quitter()}~: elle permet à l'utilisateur de quitter l'application. 
\end{itemize}
L'application dirige ensuite l'utilisateur vers une nouvelle vue en fonction du type d'utilisateur connecté et des choix effectués : organisateur à \texttt{AdministrateurVue}, Joueur à \texttt{JoueurVue} et Maître du Jeu à \texttt{MaîtreJeuVue}. Tant que la personne ne choisit pas de quitter l'application, elle navigue entre les vues.
\bigbreak

\texttt{AdministrateurVue} est la vue vers laquelle l'administrateur est redirigé après s'être connecté, elle a les fonctions suivantes :
\begin{itemize}[label=\ding{109}, font=\small]
    \item \texttt{creer\_table()}~: l'administrateur crée une table de jeu et l'application renvoie une confirmation de sa création. 
    \item \texttt{supprimer\_table()}~: l'administrateur sélectionne une table de jeu à supprimer et l'application renvoie la confirmation de sa suppression.
    \item \texttt{supprimer\_joueur()}~: l'administrateur sélectionne un Joueur à supprimer de la table à laquelle il appartient et supprime également son compte. L'application renvoie une confirmation de la suppression à l'administarteur et en informe le Joueur.
    \item \texttt{deplacer\_joueur() }~: l'administrateur sélectionne un Joueur à déployer sur une table spécifique et l'application renvoie une confirmation du déplacement et en avise le Joueur.
    \item \texttt{voir\_sommaire() }~: elle donne un résumé de toutes les tables de jeu présentes dans le conférence en ce moment, y compris l'identité du scénario, des Maîtres du Jeu et des Joueurs.
    \item \texttt{se\_deconnecter() }~: l'administrateur se déconnecte et revient à la vue d'accueil \texttt{AccueilVue}.
\end{itemize}
\bigbreak

\texttt{JoueurVue} est la vue à laquelle le Joueur accède après s'être connecté et elle lui offre les fonctions suivantes :
\begin{itemize}[label=\ding{109}, font=\small]
    \item\texttt{creer\_personnage()}~: le joueur crée un personnage via l'API mentionnée précédemment en suivant la règle de ne pas avoir plus de 3 personnages.
    \item\texttt{supprimer\_personnage()}~: le joueur supprime un personnage existant.
    \item\texttt{lister\_personnages()}~: elle donne au joueur un résumé des attributs des personnages qu'il possède.
    \item\texttt{voir\_programme()}~: le joueur visualise toutes les tables auxquelles il a participé au cours de la session.
    \item\texttt{voir\_programme()}~: le joueur voit un enregistrement de tous les jeux auxquels il a participé pendant la session, y compris les dates des jeux, les scripts, les personnages participants, etc. \textcolor{red}{A revoir}
    \item\texttt{rejoindre\_table()}~: À la suite d'informations sur les tables actuellement disponibles, telles que le scénario et les personnages enregistrés sur la table, le joueur sélectionne la table à rejoindre.
\end{itemize}



creer\_personnage(Personnage) : bool
+ supprimer\_personnage(Personnage) : bool
+ lister\_personnages(Joueur) : list[Personnage]
+ voir\_programme(Joueur) : none
+ rejoindre\_table(Table, Personnage) : bool
+ quitter\_table(Table) : bool
+ se\_deconnecter() : none






\textcolor{red}{TODO : décrire la vue JoueurVue}






\bigbreak
Dans la majorité des cas, une vue devra appeler des services. Ceux-ci effectueront les traitements métier demandés.


\subsection{Les objets métier}

Afin de modéliser notre application, nous avons listé les objets dont nous avions besoin. Il s’agit de classes objets et comme leur nom l’indique, ces classes ne disposent que d’attributs et pas de méthodes (qui elles se trouvent dans les classes de services). Ainsi les classes objets listées ci-dessous sont des business objects uniquement décrits par leur attributs. Ces business objects seront utilisés par les classes de services et celles de DAO. Les différentes classes objets sont les suivantes:

\bigbreak

\begin{itemize}
    \item \texttt{Administrateur}~: Il s’agit d’un modérateur qui n’est pas considéré comme Joueur. Cette classe possède les deux attributs suivants :
    \begin{itemize}[label=\ding{109}, font=\small]
        \item \texttt{id\_admin}~: int, un administrateur dispose d'un identifiant unique.
        \item \texttt{pseudo}~: str, comme tout membre de la conférence de jeu de rôle, un administrateur dispose d'un pseudo pour se connecter à son profil d'administrateur et accéder aux différentes vues et services dont il dispose.
    \end{itemize}

    \item \texttt{Tablejeu}~: Une même table pouvant servir à quatre reprises lors de la convention, nous parlerons de table pour le support physique, et de Table de Jeu pour l'utilisation d'une table sur une plage horaire donnée. Une Table de Jeu possède les cinq attributs suivants :
    \begin{itemize}[label=\ding{109}, font=\small]
        \item \texttt{id\_table}~: int, chaque table dispose d'un  identifiant unique.
        \item \texttt{séance}~: int, numéro de la séance sur laquelle la table est utilisée (1 pour le samedi matin, 2 pour le samedi après-midi, 3 pour le dimanche matin et 4 pour le dimanche après-midi). Ainsi une Table de Jeu est caractérisée par le couple (id\_table, séance).
        \item \texttt{scénario}~: str, scénario choisi par le Maître du Jeu pour animer la Table de Jeu.
        \item \texttt{maîtrejeu}~: MaîtreJeu, Maître du Jeu qui s'occupe de la Table de Jeu.
        \item \texttt{joueurs}~: list[Joueur], liste des Joueurs de la Table de Jeu. 
    \end{itemize}
    
    \item \texttt{Personnage}~: Il s'agit d'un personnage fictif de jeu de rôle que crée un Joueur pour participer à une session de jeu. Cette classe possède les six attributs suivants :
    \begin{itemize}[label=\ding{109}, font=\small]
        \item \texttt{id\_personnage}~: int, chaque personnage est associé à un identifiant unique.
        \item \texttt{nom}~: str, nom du personnage.
        \item \texttt{classe}~: str, classe du personnage (Guerrier, Druide, Magicien...)
        \item \texttt{race}~: str, race du personnage (Humain, Elfe, Nain...).
        \item \texttt{niveau}~: int, niveau du personnage.
        \item \texttt{compétences}~: list[str], liste des compétences dont le personnage dispose.
        \item \texttt{langues\_parlées}~: list[str], liste des langues parlées par le personnage.
    \end{itemize}

    \item \texttt{Joueur}~: C'est une personne réelle qui participe à la conférence de jeu de rôle. Cette classe possède les six attributs suivants :
    \begin{itemize}[label=\ding{109}, font=\small]
        \item \texttt{id\_joueur}~: int, identifiant unique du Joueur
        \item \texttt{pseudo}~: str, pseudo à l'aide duquel le jouer se connecte afin d'accéder aux vues et services qui lui sont propres.
        \item \texttt{nom}~: str, son nom propre, qu'il renseigne lors de l'inscription.
        \item \texttt{prénom}~: str, son prénom, qu'il renseigne lors de l'inscription.
        \item \texttt{mail}~: str, son adresse mail, qu'il renseigne lors de l'inscription.
        \item \texttt{personnages}~: list[Personnage], il s'agit de la liste des personnages que le Joueur souhaite potentiellement utiliser lors de la conférence. On limitera le nombre de personnages qu'il peut créer à 3.
    \end{itemize}
\end{itemize}

\bigbreak

La classe \texttt{Maîtrejeu} est une classe qui hérite des attributs de la classe Joueur. Ce qui différencie un Maître du Jeu d'un Joueur réside dans les fonctionnalités dont ils disposent et les vues de chacun (cf couches vues et services). Aucune différenciation n'est faite au niveau des attributs du Joueur et du Maître du Jeu.







\subsection{La couche Service}

La couche service est le coeur de notre application. Elle contient toutes les méthodes qui permettront ensuite de répondre aux besoins des utilisateurs.




\bigbreak


La classe \texttt{OrganisateurService} possède les méthodes suivantes :
\begin{itemize}[label=\ding{109}, font=\small]
    \item \texttt{créer\_table(num\_seance)}~: 
    \item \texttt{supprimer\_table(TableJeu)}~: 
    \item \texttt{supprimer\_joueur(Joueur)}~: 
    \item \texttt{déplacer\_joueur(Joueur, TableJeu avant, TableJeu après)}~: 
    \item \texttt{déplacer\_mj(MaitreJeu, TableJeu avant, TableJeu après)}~: 
    \item \texttt{voir\_programme\_complet()}~: 
\end{itemize}

\bigbreak

La classe \texttt{JoueurService} possède les méthodes suivantes :
\begin{itemize}[label=\ding{109}, font=\small]
    \item \texttt{créer(pseudo, nom, prenom, mail)}~: 
    \item \texttt{supprimer(Joueur)}~: 
    \item \texttt{créer\_personnage(nom, niveau, classe, race)}~: 
    \item \texttt{supprimer\_personnage(Personnage)}~: 
    \item \texttt{lister\_personnages()}~: elle liste tous les personnages du joueur ainsi que leurs caractéristiques.
    \item \texttt{voir\_tables\_libres()}~: cette méthode affiche par séance la liste des tables qu'il est possible de rejoindre.
    \item \texttt{rejoindre\_table(TableJeu, Personnage)}~: après vérification qu'une place est libre à la table de jeu, et que le joueur est lui même libre, cette méthode affecte le personnage à la table.
    \item \texttt{quitter\_table(TableJeu)}~: Le joueur est supprimé de la \texttt{TableJeu} en paramètre s'il était effectivement installé à cette table.
    \item \texttt{voir\_son\_programme()}~: cela liste l'emploi du temps du joueur (tables, scénario, personnage)
    \item \texttt{devenir\_mj()}~: le joueur devient Maître du Jeu.
\end{itemize}


\bigbreak


La classe \texttt{MaitreJeuService} possède les méthodes suivantes :

\begin{itemize}[label=\ding{109}, font=\small]
    \item \texttt{gérer\_table(num\_seance, TableJeu, scenario)}~: elle prend trois paramètres : un numéro de séance, une \texttt{TableJeu} et une chaîne de caractères contenant la description du scénario. En premier lieu, une vérification est faite sur la disponibilité du Maître du Jeu. S'il n'est pas disponible, un message d'erreur est retourné. Le paramètre \texttt{TableJeu} est optionnel~: s'il n'est pas renseigné, le Maître du Jeu est affecté aléatoirement à une table vide de la séance. Si la table est renseignée, le programme s'assure qu'il n'y a pas déjà un Maître du Jeu à cette table. Si tout est valide, la \texttt{TableJeu} choisie est enrichie avec le \texttt{MaitreJeu} et le scénario.
    
    \item \texttt{résilier\_table(TableJeu)}~: Si le Maître du Jeu n'est pas en charge de la table choisie, cela renvoie un message d'erreur. Sinon la \texttt{TableJeu} perd son \texttt{MaitreJeu}, son scénario et tous ses \texttt{Joueurs}.
    
    \item \texttt{voir\_table\_geree()}~: elle prend un numéro de table en paramètre et affiche la liste des Joueurs de la table, leurs personnages et leurs niveaux si l'utilisateur est bien Maître du Jeu de la table. Dans le cas contraire, un message d'erreur apparaît.
\end{itemize}





\subsection{Couche DAO et base de données}

La couche DAO (Data Access Object) permet de faire le lien entre notre application et la base de données PostrgreSQL sur laquelle sont sauvegardées les données.

% Diagramme de base de données







%-------------------------------------------------------------------------------
% Conclusion
%-------------------------------------------------------------------------------

% PAS DE CONCLUSION...

% \section*{Conclusion}
% \addcontentsline{toc}{section}{Conclusion}


%-------------------------------------------------------------------------------
% Annexes
%-------------------------------------------------------------------------------

\newgeometry{top=0.5cm, bottom=0.1cm}

\addcontentsline{toc}{section}{Annexes}
\appendix  % On passe aux annexes
\section*{Annexe 1 - Diagramme de classe UML}


\begin{figure}[H]
    \label{UML_classes}
    \centering
    \includegraphics[angle=90,height=0.9\textheight]{UML_diagrammes/diag_classes.png}
\end{figure}


\restoregeometry




\newpage

\section*{Annexe 2 - Utilisation de Git sur notre projet}

\textcolor{red}{Ludo : je vais supprimer cet annexe mais je laisse pour l'instant si vous voulez voir comment on fonctionne avec Git sur un projet}


Git est un logiciel de gestion de versions. Il facilite, pour chaque développeur, la synchronisation entre le dépôt local (le code qui est sur notre ordinateur) et le dépôt distant sur GitHub (le code commun). Il est ainsi beaucoup plus simple de travailler sur un même projet et d'éviter les décalages de versions. Dans le cadre de notre projet, nous utiliserons les fonctionnalités basiques de Git. Nous avons mis en place le protocole ci-dessous.

\bigbreak

Notre dépôt est organisé avec les dossiers suivants :
\begin{itemize}
    \item src : contient les fichiers python
    \item doc : fichiers de documentation (cahier des charges, diagrammes UML...)
    \item donnees : contient des fichiers de données, des fichiers tests et un dossier \texttt{exports} où seront générés tous les exports. 
\end{itemize}


\subsection*{Avant de commencer à coder}

\begin{itemize}
    \item Dans Visual Studio Code, j'ouvre un terminal Git Bash
    \item Menu View > Terminal (ou CTRL+ù)
    \item je clique sur la petite flèche vers le bas à coté du +, puis sur Git Bash
    \item Normalement je suis placé directement dans le bon dossier et dans la console s'affiche : 
\end{itemize}


\noindent
\verb"idxxxx yyyyyy /p/projet-info-sources/Projet-info (main)" \\
\verb"git pull      # permet de mettre à jour le dépôt local avec le dépôt distant"




\subsection*{Je code}

\begin{itemize}
    \item je crée/modifie/supprime des fichiers python (ou autre)
    \item je teste que ça fonctionne bien
    \item une fois que j'ai un morceau de code qui fonctionne, je crée un \textbf{commit} (point de sauvegarde)
    \item il est très important de faire régulièrement un commit dès que quelque chose fonctionne bien. Cela évitera de perdre beaucoup de temps si ensuite par une action malheureuse, le code ne fonctionnait plus du tout. Dans ce cas, un simple retour arrière au dernier commit et l'on peut repartir sur de bonnes bases
\end{itemize}

\noindent
\verb"git add .    # permet d'ajouter tous les nouveaux fichiers créés" \\
\verb"git status   # pour voir les changements en cours" \\
\verb"git commit -am «~message explicite~»     # Pour créer un commit" \\

\bigbreak

Si par la suite je fais une erreur, il est facile de revenir en arrière (au dernier commit) :\\
\verb"git reset --hard" 

\bigbreak

Attention cette commande supprime toutes les modifications effectuées depuis le dernier commit. Par sécurité, je crée une copie du dossier \textbf{Projet-info} avant de lancer la commande.



\subsection*{Je partage mon travail}

\begin{itemize}
    \item Si personne n'a poussé du code entre temps, tout va bien, je vais pouvoir faire un \textbf{push}
    \item Par contre si le dépôt distant a été modifié, je dois synchroniser mon dépôt local avec les mises à jour effectuées sur le dépôt distant par d'autres membres de l'équipe
    \item Si vous n'avez pas touché aux mêmes fichiers, Git va effectuer la fusion tout seul lors du \textbf{git pull}
    \item Si vous avez touché au même fichier, ça se complique un peu. Git va dire qu'il n'a pas réussi de fusion automatique (\textit{CONFLICT (content): Merge conflict - Automatic merge failed}). Il faut ouvrir les fichiers en conflit et ceci apparaît : 
\end{itemize}


\noindent
\verb"<<<<<<< HEAD" \\
\verb"« Les modifications que j'ai faites »" \\
\verb"=======" \\
\verb"« Les modifications faites par un autre membre de l'équipe »" \\
\verb">>>>>>>" \\

\begin{itemize}
    \item je modifie le fichier pour choisir quelle modification je garde
    \item je teste et je vérifie que tout est ok
    \item je recrée un commit \verb"git commit -am « merge manuel »"
    \item et enfin, je peux faire \verb"git push"
\end{itemize}

\noindent
\verb"git pull           # pour récupérer les éventuelles modifications du dépôt distant" \\
\verb"git status         # pour voir s'il n'y a pas de conflits" \\
\verb"git push           # pousser son code vers le dépôt distant" \\



\subsection*{Commandes Git : ce qu'il faut retenir}

\noindent
\verb"git status               # Voir ce qui est en cours" \\
\verb"git pull                 # Copier dépôt distant vers dépôt local" \\
\verb"git push                 # Copier dépôt local vers dépôt distant" \\
\verb"git add .                # Avant un commit pour que git identifie les nouveaux fichiers" \\
\verb"git commit -am « message » # Créer un point de sauvegarde" \\
\verb"git diff                 # Avant de faire un commit, voir les différences" \\








\end{document}

