\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{multirow}
\usepackage{amsmath,amssymb}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{awesomebox}
\usepackage{tcolorbox}
\usepackage{xcolor}
\usepackage{pifont}
\usepackage[top=1.5cm,bottom=1.5cm,margin=2.5cm]{geometry}


\graphicspath{{Images/}} %le chemin vers les images

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}


%-------------------------------------------------------------------------------
% Page de garde
%-------------------------------------------------------------------------------

\begin{titlepage}
\begin{center}


\textsc{{\LARGE Ecole nationale de la statistique \\et de l'analyse de l'information}} \\ %Nom de l'école
\vspace{5mm}
\includegraphics[width=0.4\textwidth]{ensai_logo}\\[2 cm] %logo de l'école

%\textsc{\LARGE Projet de traitement de données }\\[0.5cm] % Nom de cours


% Title
\HRule \\[0.4cm]
{ \huge \bfseries Projet informatique \\ \ \\ Dossier d'analyse}\\[0.4cm]

\HRule \\[1cm]

{\Large 2ème Année}\\ [2cm]

% Auteur(s) et Superviseur(s)

\begin{flushleft} \Large
\emph{Etudiants :}\\
Ludovic \textsc{Deneuville} \\
Jean-François \textsc{Parriaud} \\
Jason \textsc{Torres} \\
Hugo \textsc{Wispelaere} \\
Banruo \textsc{Zhang} \\
\end{flushleft}

\begin{flushright} \Large
\emph{Professeur:} \\
Rémi \textsc{Pépin} \\
\emph{Encadrant:} \\
Cyriel \textsc{Mallart} \\
\end{flushright}


\vfill
{\large 2022 - 2023}
\end{center}
\end{titlepage} 


%-------------------------------------------------------------------------------
% Table des matieres
%-------------------------------------------------------------------------------

\renewcommand{\contentsname}{Sommaire}
\tableofcontents
\newpage


%-------------------------------------------------------------------------------
% Introduction
%-------------------------------------------------------------------------------

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

Les personnes impliquées dans un événement public se divisent en trois catégories: les organisateurs, les intervenants et le public. Dans le cadre d'une conférence, les intervenants (les conférenciers) sont choisis par les organisateurs. Leur nombre est fixé par avance en fonction de plusieurs critères: contraintes horaires, salles disponibles, budget, et ce nombre n'est pas destiné à évoluer, sauf cas de force majeure tel un désistement. Les organisateurs gèrent le nombre de personnes dans le public (l'auditoire) de façon relativement linéaire (inscriptions, désistements éventuels). Le nombre de personnes dans le public n'est pas limité par le nombre d'intervenants mais par les capacités d'accueil des salles. Ainsi, il est possible d'accueillir des personnes sans réservation dans la limites des places disponibles et il n'est pas nécessaire de gérer la répartition de l'auditoire.\\

L'organisation d'une convention est différente. En effet les intervenants ne sont pas engagés par les organisateurs mais sont des volontaires, oeuvrant bénévolement pour partager leur passion. Ils doivent pouvoir s'inscrire ou se désister librement et chaque intervenant a la charge de quelques membres du public. Par conséquent, le public ne peut s'inscrire qu'à condition qu'il y ait des intervenants pour les encadrer (en pratique, les organisateurs auront tendance à faire la promotion de leur convention auprès de communautés susceptibles de fournir des intervenants avant de lancer la phase d'inscription). Il faut par conséquent pouvoir gérer son effectif et sa répartition au fil de l'eau en fonction du nombre d'intervenants disponibles et des capacités d'accueil de la salle. Toutes ces contraintes font que l'organisation d'une convention est complexe et notre but est de fournir un outil approprié sous forme d'application. \\



\newpage

%-------------------------------------------------------------------------------
% Section 1
%-------------------------------------------------------------------------------

\section{Analyse du besoin}

\subsection{Cahier des charges}

L'objectif de ce projet est de développer une application qui permette de gérer l'organisation d'une convention. Cette application devra être utilisable aussi bien par les organisateurs que par les intervenants et le public.  \\

Nous nous sommes basés sur le principe d'une convention se déroulant sur un week-end et comportant quatre plages horaires, chacune correspondant à une demi-journée. Cette convention est dédiée aux jeux de rôle, aussi les intervenants seront par la suite appelés «~Maîtres du Jeu~» ou MJ. Le public venant quant à lui pour jouer, ses membres seront appelés «~Joueurs~».\\ 

L'application permettra à quiconque le souhaite de s'inscrire en tant que Joueur. Les Joueurs auront accès à plusieurs fonctionnalités. La première d'entre elles sera la création de personnages, dans une limite de trois. Un appel à l'API suivante \textcolor{blue}{\href{https://www.dnd5eapi.co/}{https://www.dnd5eapi.co/}} permettra de compléter les informations sur les personnages. La détention de personnages permettra au Joueur de s'asseoir à une table par demi-journée. Afin de pouvoir faire un choix éclairé, les Joueurs pourront visualiser, pour chaque table ouverte et disponible, le scénario proposé et ainsi choisir le personnage adéquat. Les Joueurs pourront aussi visualiser un sommaire de leur participation et, le cas échéant, se désister d'une table, ce qui sera automatiquement notifié aux organisateurs.\\

L'application permettra aux Joueurs le désirant de s'inscrire en tant que Maîtres du Jeu. Ceux-ci auront la possibilité, pour chaque demi-journée, de choisir une table.  Ils en définiront le scénario proposé, offrant ainsi à quatre Joueurs la possibilité de s'y inscrire. Ils pourront aussi visualiser les profils des Joueurs inscrits à leur table, afin de mieux préparer leur intervention. En outre, ils auront la possibilité de voir un sommaire de leur participation. Enfin, si nécessaire, ils pourront se désister, entraînant une notification aux organisateurs. Les organisateurs auront alors la charge d'affecter les Joueurs à une autre table dans la mesure du possible, ou d'annuler leur participation à cette demi-journée si nécessaire.\\

\indent Il a été envisagé de différencier totalement les profils Joueur et Maître du Jeu, en leur attribuant des comptes séparés pour une même personne physique. Cela présentait deux inconvénients:
\begin{itemize}
\item{compliquer la gestion des erreurs humaines. En effet, une même personne ne peut pas physiquement participer à deux tables en même temps. Pour chaque compte nous pourrons avoir accès à une liste des tables auxquelles la personne participe. Avoir les comptes Joueur et Maître du Jeu joints signifie la présence d'une unique liste de tables à vérifier. Des comptes séparés auraient entraîné la création de deux listes séparées et, par conséquent, la nécessité de systématiquement vérifier si un compte Maître du Jeu est détenu par une personne ayant aussi un compte Joueur et vice-versa.}
\item{compliquer l'utilisation de l'application pour une personne désirant être à la fois Maître du Jeu et Joueur. En effet, cette personne aurait dû systématiquement se déconnecter et s'authentifier pour passer d'un compte à l'autre.\\}
\end{itemize}

Enfin, les organisateurs de la convention auront un profil spécifique. Du point de vue de l'application, ils seront considérés comme Administrateurs et pourront visualiser un sommaire global de l'activité sur la convention. L'envoi automatique de notifications lors de désistements de Joueurs ou de Maîtres du Jeu leur permettra d'être toujours avertis des changements intervenus. Ils seront en mesure de modifier ou supprimer la participation d'un Maître du jeu ou d'un Joueur, entraînant une notification aux personnes concernées.\\

Un système sommaire d'accès par pseudo sera mis en place, par souci de simplicité. Il permettra à la fois de différencier les statuts des protagonistes et de cloisonner les profils individuels. Il sera toujours possible par la suite de mettre en place un système plus sécurisé avec mot de passe. \\



\subsection{Fonctionnalités attendues}

Le diagramme de cas d'utilisation est montré ci-après en figure \ref{UML_classe_pipeline}. \\

On désigne par «~Utilisateur~» toute personne lançant l'application. Un Utilisateur, lorsqu'il lance le programme, a trois actions à sa disposition~:
\begin{itemize}
    \item{S'inscrire~: l'Utilisateur peut se créer un compte Joueur. Il devra alors donner quelques renseignements sur son identité (nom, prénom, mail, pseudo...) avant de se voir attribuer un identifiant.}
    \item{S'authentifier~: Si l'Utilisateur possède déjà un compte avec un profil Joueur ou Administrateur, il devra indiquer son pseudo pour avoir accès aux fonctionnalités liées à son profil. Dans le cadre de ce projet, aucun mot de passe n'est nécessaire pour se connecter.}
    \item{Quitter~:  Fermer l'application.\\}
\end{itemize}

Les Administrateurs ont le choix entre les six actions suivantes~:
\begin{itemize}
    \item {Déplacer joueur~: lorsque plusieurs tables comptent un trop faible nombre de Joueurs, ou lorsqu'un Maître du Jeu s'est désisté, les Administrateur peuvent placer les Joueurs sur d'autres tables ou annuler leur participation sur la plage horaire concernée. Dans ce cas, le Joueur est notifié de ce changement par un message qui s'affichera lors de sa prochaine connexion.}
    \item{Déplacer MJ~: dans le même cas de figure, les Administrateurs peuvent placer un Maître du Jeu sur une autre table ou annuler sa participation sur la plage horaire concernée. Dans ce cas, le Maître du Jeu est notifié de ce changement par un message qui s'affichera lors de sa prochaine connexion.}
    \item{Supprimer joueur~: les Administrateurs ont la possibilité de supprimer le compte d'un Joueur en cas de comportement inapproprié.}
    \item{Ajouter/supprimer table~: si de nombreuses tables sont complètes, les Administrateurs ont la possibilité de créer de nouvelles tables. À l'inverse ils peuvent supprimer une table. Pour être supprimée, une table doit être vide, c'est-à-dire que les Administrateurs doivent déplacer au préalable les Joueurs et le Maître du Jeu assis à cette table.}
    \item{Voir programme complet~: les Administrateurs peuvent visualiser sur l'ensemble de la conférence la liste de toutes les tables, avec le scénario, les identités du Maître du Jeu et des Joueurs.}
    \item{Se déconnecter~: les Administrateurs mettent fin à leur session et redeviennent Utilisateurs du point de vue de l'application.\\}
\end{itemize}

Les Joueurs ont le choix entre six actions~:
\begin{itemize}
    \item {Se déconnecter~: le Joueur met fin à sa session et redevient Utilisateur du point de vue de l'application.}
    \item{Voir messages~: le Joueur a accès aux notifications qui lui ont été envoyées. Par exemple celles qui concernent un changement sur son emploi du temps.}
    \item{Créer/supprimer personnage~: le Joueur peut créer un personnage via l'API mentionnée précédemment. Il peut aussi supprimer ce personnage dans la base de données.}
    \item{Rejoindre/quitter table~: le Joueur peut choisir de participer à une table de jeu. Il pourra alors visualiser les tables ouvertes par les Maîtres du Jeu et les scénarios proposés et indiquera le personnage qu'il incarnera sur cette table. Il peut aussi quitter une table sur laquelle il s'était auparavant inscrit.}
    \item{Voir programme~: le Joueur peut visualiser toutes les tables de jeu auxquelles il participe, sur l'ensemble de la conférence.}
    \item{Devenir maître du jeu: le Joueur peut s'inscrire en tant que Maître du Jeu.\\}
\end{itemize}

Un Joueur inscrit comme Maître du Jeu accède à trois fonctionnalités supplémentaires:
\begin{itemize}
    \item{Gérer une table~: il pourra voir les tables disponibles mais non ouvertes par un autre Maître du Jeu, en choisir une, et indiquer le scénario qu'il prévoit pour cette table, avec éventuellement des recommandations concernant les niveaux des personnages des Joueurs.}
    \item{Résilier une table~: il peut également décider de ne plus officier en tant que Maître du jeu sur une table.}
    \item{Voir joueurs d'une table~: il aura accès aux informations concernant les Joueurs des tables sur lesquelles il officie, ainsi que leurs personnages.\\}
\end{itemize}

\begin{figure}[H]
    \caption{\textbf{Diagramme de cas d'utilisation}}
    \label{UML_classe_pipeline}
    \centering
    \includegraphics[height=0.9\textheight]{UML_diagrammes/diag_cas_utilisation.png}
\end{figure}


\subsection{Organisation d'équipe}

Lors du démarrage de notre projet, nous avons évoqué plusieurs sujets importants pour une organisation d'équipe efficace et une bonne entente. Le premier sujet évoqué concerne les règles de vie dans notre équipe. Chacun des membres devra respecter les autres, communiquer, être solidaire, être force de proposition, anticiper et ne pas travailler à la dernière minute.


\bigbreak

Ensuite nous avons parlé de la liste de nos compétences et appétences par rapport aux besoins sur ce projet (connaissances en informatique, python, base de données, rédaction...). Ainsi nous nous sommes répartis les rôles suivants:
\begin{itemize}
    \item{Chef de projet~: suivi du projet, organisation, vérification que chacun sait ce qu’il doit faire}
    \item{Responsable de la communication~: s'occupe de la communication avec les intervenants externes}
    \item{Maître du temps~: s’assure que les délais sont bien respectés}
    \item{Expert technique~: assiste les développeurs en cas de problème technique}
    \item{Rédacteur en chef~: Valide les rapports, s'occupe de la mise en forme, corrige les fautes}
\end{itemize}

Nous avons également convenu que tous les membres de l'équipe participeront au développement du code.

\bigbreak

Nous utiliserons ces outils pour répondre à des besoins concernant différents aspects de ce projet :
\begin{itemize}
    \item{Suivi et communication~: \href{https://hackmd.io/CMTCDVW6Spe2PHXOhdKTRQ}{hackMd}, Discord}
    \item{Analyse et Rédaction~: PlantUML, LateX}
    \item{Développement~: langage Python, Visual Studio Code, bdd PostgreSQL, DBeaver, fastApi}
    \item{Gestion de version~: Git, GitHub}
\end{itemize}


\bigbreak

Le diagramme de Gantt relatif à l'organisation de notre équipe est montré en figure \ref{UML_gantt}.\\


\begin{figure}[H]
    \caption{\textbf{Diagramme de Gantt}}
    \label{UML_gantt}
    \centering
    \includegraphics[height=0.5\textheight]{UML_diagrammes/diag_gantt.png}
\end{figure}

La troisième strate illustre les différentes phases du projet. Les six premières semaines ont été consacrées à l'étude et à la conception du projet, incluant la réalisation des diagrammes présentés dans ce dossier et la documentation. Pendant ce temps, les cours et TP nécessaires à la réalisation concrète de l'application (Programmation Orientée Objet, Webservices, Git) ont pu avoir lieu. La phase de développement, incluant le codage de l'application et la mise en place de la base de données, se déroulera ensuite sur une période d'environ six semaines. Lorsque cette phase sera bien avancée, la rédaction d'un rapport final pourra débuter, suivie par la préparation de la présentation de notre travail lors de la soutenance.\\

La dernière strate montre les tâches concrètes à réaliser et est complétée au fur et à mesure.\\





%-------------------------------------------------------------------------------
% Section 2
%-------------------------------------------------------------------------------

\newpage
\section{Conception}

\subsection{Modélisation}

L'application sera découpée en trois couches :
\begin{itemize}
    \item \texttt{Couche de Vue} : elle contiendra les classes qui gèrent l'interface avec l'utilisateur,
    \item \texttt{Couche de Service} : elle regroupe les classes qui contiennent les procédures métier,
    \item \texttt{Couche DAO} : ensemble de classes permettant d'accéder à la base de données.
\end{itemize}

\bigbreak

Les objets métier seront regroupés dans un package nommé \texttt{business\_objects}.

\subsection{La couche Vue}

Les classes de la couche de visualisation représentent l'interface par laquelle l'utilisateur peut accéder à l'application, lui donnant ainsi la possibilité d'accéder aux fonctionnalités de l'application. Notre programme sera utilisé via un terminal en utilisant le package \texttt{InquirerPy}.
\bigbreak

Les vues héritent toutes de la classe abstraite \texttt{VueAbstraite}. Elle contient les attributs et méthodes suivantes :
\begin{itemize}
    \item \texttt{questions}~: attribut au format json utilisé par le package \texttt{InquirerPy}. Il représente les questions posées à l'utilisateur. Cette question est dans certains cas un choix entre plusieurs possibilités d'un menu (par exemple, dans la Vue de connexion de l'utilisateur : il doit choisir l'une des trois options suivantes : s'inscrire, se connecter et quitter. ). Dans d'autres cas cet attribut contiendra un ensemble de questions auxquelles l'utilisateur devra répondre,  (par exemple dans le cas de la vue correspondant au formulaire d'inscription, l'utilisateur devra entrer un par un : pseudo, nom, prenom...).
    \item \texttt{message}~: attribut contenant un message qui s'affichera lorsque la vue sera appelée. Ce message aura été transmis par la vue précédente. Par exemple, l'utilisateur vient de se s'inscrire, il est redirigé vers la vue d'accueil qui affichera un message spécifiant si l'inscription est réussie.
    \item \texttt{afficher()}~: méthode permettant d'afficher des messages lors de l'appel de la vue.
    \item \texttt{choisir\_menu()}~: cette méthode affiche les questions posées à l'utilisateur. Selon la ou les réponses reçues, elle aiguille le programme vers une nouvelle vue.
\end{itemize}

\bigbreak

Lorsque l'application se lance, l'utilisateur va être dirigé vers la vue \texttt{AccueilVue}. Il verra s'afficher le menu suivant~:
\begin{itemize}[label=\ding{109}, font=\small]
    \item \texttt{1. Créer un compte Joueur}~: il est envoyé vers \texttt{InscriptionVue}
    \item \texttt{2. Se connecter}~: il est dirigé vers \texttt{ConnexionVue}
    \item \texttt{3. Quitter}
\end{itemize}

\bigbreak

La vue \texttt{InscriptionVue} représente un formulaire d'inscription. On demande sous forme de questions de renseigner nom, prénom, pseudo, mail. Une fois toutes les réponses données, le service de création de joueur est appelé et l'utilisateur est dirigé vers la vue \texttt{AccueilVue}. Un message indique si la création de compte Joueur a aboutie. La vue \texttt{ConnexionVue} demande simplement à l'utilisateur de saisir son pseudo. Si le pseudo est valide, la personne est orienté vers~:
\begin{itemize}[label=\ding{109}, font=\small]
    \item \texttt{JoueurMenuVue} si le pseudo est celui d'un joueur.
    \item \texttt{MaitreJeuMenuVue} si le pseudo est celui d'un maître du jeu.
    \item \texttt{AdministrateurMenuVue} si le pseudo est \texttt{admin}.
\end{itemize}




\bigbreak


\texttt{AdministrateurVue} est la vue vers laquelle l'Administrateur est redirigé après s'être connecté, elle a les fonctions suivantes :
\begin{itemize}[label=\ding{109}, font=\small]
    \item \texttt{creer\_table()}~: l'Administrateur crée une table de jeu et l'application renvoie une confirmation de sa création. 
    \item \texttt{supprimer\_table()}~: l'Administrateur sélectionne une table de jeu à supprimer et l'application renvoie la confirmation de sa suppression.
    \item \texttt{supprimer\_joueur()}~: l'Administrateur supprime le compte d'un joueur. L'application renvoie une confirmation de la suppression à l'Administrateur.
    \item \texttt{deplacer\_joueur() }~: l'Administrateur sélectionne un Joueur sur une table et l'affecte sur une autre table. L'application renvoie une confirmation du déplacement et en avise le Joueur.
    \item \texttt{voir\_sommaire() }~: elle donne un résumé de toutes les tables de jeu présentes dans la convention en ce moment, y compris l'identité du scénario, des Maîtres du Jeu et des Joueurs.
    \item \texttt{se\_deconnecter() }~: l'Administrateur se déconnecte et revient à la vue d'accueil \texttt{AccueilVue}.
\end{itemize}
\bigbreak

\texttt{JoueurVue} est la vue à laquelle le Joueur accède après s'être connecté, elle lui offre les fonctionnalités suivantes :
\begin{itemize}[label=\ding{109}, font=\small]
    \item\texttt{creer\_personnage()}~: le Joueur crée un personnage via l'API mentionnée précédemment en suivant la règle de ne pas avoir plus de trois personnages.
    \item\texttt{supprimer\_personnage()}~: le Joueur supprime un personnage existant.
    \item\texttt{lister\_personnages()}~: elle donne au Joueur un résumé des attributs des personnages qu'il possède.
    \item\texttt{voir\_programme()}~: le Joueur visualise toutes les tables auxquelles il va participer au cours de la session.
    \item\texttt{voir\_programme()}~: le Joueur voit un enregistrement de tous les jeux auxquels il a participé pendant la session, y compris les dates des jeux, les scripts, les personnages participants, etc. \textcolor{red}{A revoir}
    \item\texttt{rejoindre\_table()}~: À la suite d'informations sur les tables actuellement disponibles, telles que le scénario et les personnages enregistrés sur la table, le Joueur sélectionne la table à rejoindre.
\end{itemize}



creer\_personnage(Personnage) : bool
+ supprimer\_personnage(Personnage) : bool
+ lister\_personnages(Joueur) : list[Personnage]
+ voir\_programme(Joueur) : none
+ rejoindre\_table(Table, Personnage) : bool
+ quitter\_table(Table) : bool
+ se\_deconnecter() : none






\textcolor{red}{TODO : décrire la vue JoueurVue}






\bigbreak
Dans la majorité des cas, une vue devra appeler des services. Ceux-ci effectueront les traitements métier demandés.


\subsection{Les objets métier}

Afin de modéliser notre application, nous avons listé les objets dont nous avions besoin. Il s’agit de classes objets et comme leur nom l’indique, ces classes ne disposent que d’attributs et pas de méthodes (qui elles se trouvent dans les classes de services). Ces business objects seront utilisés par les classes de services et celles de DAO. Les différentes classes objets sont les suivantes:

\bigbreak

\begin{itemize}
    \item \texttt{Administrateur}~: C'est l'un des organisateurs de la convention, il n’est pas considéré comme Joueur. Cette classe possède les deux attributs suivants :
    \begin{itemize}[label=\ding{109}, font=\small]
        \item \texttt{id\_admin}~: int, un Administrateur dispose d'un identifiant unique.
        \item \texttt{pseudo}~: str, comme tout membre de la convention de jeu de rôle, un Administrateur dispose d'un pseudo pour se connecter à son profil d'administrateur et accéder aux différentes vues et services dont il dispose.
    \end{itemize}

    \item \texttt{Tablejeu}~: Une même table pouvant servir à quatre reprises lors de la convention, nous parlerons de table pour le support physique, et de Table de Jeu pour l'utilisation d'une table sur une plage horaire donnée. Une Table de Jeu possède les cinq attributs suivants :
    \begin{itemize}[label=\ding{109}, font=\small]
        \item \texttt{id\_table}~: int, chaque table dispose d'un  identifiant unique.
        \item \texttt{séance}~: int, numéro de la séance sur laquelle la table est utilisée (1 pour le samedi matin, 2 pour le samedi après-midi, 3 pour le dimanche matin et 4 pour le dimanche après-midi). Ainsi une Table de Jeu est caractérisée par le couple (id\_table, séance).
        \item \texttt{scénario}~: str, scénario choisi par le Maître du Jeu pour animer la Table de Jeu.
        \item \texttt{maîtrejeu}~: MaîtreJeu, Maître du Jeu qui s'occupe de la Table de Jeu.
        \item \texttt{joueurs}~: list[Joueur], liste des Joueurs de la Table de Jeu. 
    \end{itemize}
    
    \item \texttt{Personnage}~: Il s'agit d'un personnage fictif de jeu de rôle que crée un Joueur pour participer à une session de jeu. Cette classe possède les six attributs suivants :
    \begin{itemize}[label=\ding{109}, font=\small]
        \item \texttt{id\_personnage}~: int, chaque personnage est associé à un identifiant unique.
        \item \texttt{nom}~: str, nom du personnage.
        \item \texttt{classe}~: str, classe du personnage (Guerrier, Druide, Magicien...)
        \item \texttt{race}~: str, race du personnage (Humain, Elfe, Nain...).
        \item \texttt{niveau}~: int, niveau du personnage.
        \item \texttt{compétences}~: list[str], liste des compétences dont le personnage dispose.
        \item \texttt{langues\_parlées}~: list[str], liste des langues parlées par le personnage.
    \end{itemize}

    \item \texttt{Joueur}~: C'est une personne réelle qui participe à la convention de jeu de rôle. Cette classe possède les six attributs suivants :
    \begin{itemize}[label=\ding{109}, font=\small]
        \item \texttt{id\_joueur}~: int, identifiant unique du Joueur
        \item \texttt{pseudo}~: str, pseudo à l'aide duquel le Joueur se connecte afin d'accéder aux vues et services qui lui sont propres.
        \item \texttt{nom}~: str, son nom propre, qu'il renseigne lors de l'inscription.
        \item \texttt{prénom}~: str, son prénom, qu'il renseigne lors de l'inscription.
        \item \texttt{mail}~: str, son adresse mail, qu'il renseigne lors de l'inscription.
        \item \texttt{personnages}~: list[Personnage], il s'agit de la liste des personnages que le Joueur souhaite potentiellement utiliser lors de la convention. On limitera le nombre de personnages qu'il peut créer à trois.
    \end{itemize}
\end{itemize}

\bigbreak

La classe \texttt{Maîtrejeu} est une classe qui hérite des attributs de la classe Joueur. Ce qui différencie un Maître du Jeu d'un Joueur réside dans les fonctionnalités dont ils disposent et les vues de chacun (cf couches vues et services). Aucune différenciation n'est faite au niveau des attributs du Joueur et du Maître du Jeu.







\subsection{La couche Service}

La couche service est le coeur de notre application. Elle contient toutes les méthodes qui permettront ensuite de répondre aux besoins des utilisateurs.




\bigbreak


La classe \texttt{AdministrateurService} possède les méthodes suivantes :
\begin{itemize}[label=\ding{109}, font=\small]
    \item \texttt{créer\_table(num\_seance)}~: ajouter une Table de Jeu à la convention.
    \item \texttt{supprimer\_table(TableJeu)}~: supprimer une Table de Jeu.
    \item \texttt{supprimer\_joueur(Joueur)}~: supprimer le compte d'un joueur.
    \item \texttt{déplacer\_joueur(Joueur, TableJeu avant, TableJeu après)}~: déplacer un joueur d'une Table de Jeu sur une autre.
    \item \texttt{déplacer\_mj(MaitreJeu, TableJeu avant, TableJeu après)}~: déplacer un Maître du Jeu d'une Table de Jeu sur une autre.
    \item \texttt{voir\_programme\_complet()}~: consulter, pour l'ensemble de la convention, un sommaire des Tables de Jeu, comprenant l'identité du Maître du Jeu, le scénario proposé et l'identité des Joueurs.
\end{itemize}

\bigbreak

La classe \texttt{JoueurService} possède les méthodes suivantes :
\begin{itemize}[label=\ding{109}, font=\small]
    \item \texttt{créer(pseudo, nom, prenom, mail)}~: elle crée un profil Joueur à partir des renseignements indiqués lors de l'inscription.
    \item \texttt{supprimer(Joueur)}~: elle permet à un Administrateur de supprimer le compte d'un joueur.
    \item \texttt{créer\_personnage(nom, niveau, classe, race, compétences, langues parlées)}~: après avoir vérifié que le joueur n'a pas atteint son quota de trois personnages, elle crée un nouveau personnage à partir des caractéristiques choisies via l'API.
    \item \texttt{supprimer\_personnage(Personnage)}~: elle supprime un personnage appartenant au joueur appelant cette méthode.
    \item \texttt{lister\_personnages()}~: elle liste tous les personnages du joueur ainsi que leurs caractéristiques.
    \item \texttt{voir\_tables\_libres()}~: cette méthode affiche par séance la liste des tables qu'il est possible de rejoindre.
    \item \texttt{rejoindre\_table(TableJeu, Personnage)}~: après vérification qu'une place est libre à la Table de Jeu, et que le Joueur est lui même libre, cette méthode affecte le personnage à la Table de Jeu.
    \item \texttt{quitter\_table(TableJeu)}~: Le Joueur est supprimé de la \texttt{TableJeu} en paramètre s'il était effectivement installé à cette table.
    \item \texttt{voir\_son\_programme()}~: cela liste l'emploi du temps du Joueur (Tables de Jeu, scénario, personnage)
    \item \texttt{devenir\_mj()}~: le Joueur devient Maître du Jeu.
    \item \texttt{afficher\_messages()}~: affiche un message au joueur lui indiquant si un changement de table ou autre action menée par l'administrateur a affecté sa participation au jeu de rôle à une table donnée.
\end{itemize}


\bigbreak


La classe \texttt{MaitreJeuService} possède les méthodes suivantes :

\begin{itemize}[label=\ding{109}, font=\small]
    \item \texttt{gérer\_table(num\_seance, TableJeu, scenario)}~: elle prend trois paramètres : un numéro de séance, une \texttt{TableJeu} et une chaîne de caractères contenant la description du scénario. En premier lieu, une vérification est faite sur la disponibilité du Maître du Jeu. S'il n'est pas disponible, un message d'erreur est retourné. Le paramètre \texttt{TableJeu} est optionnel~: s'il n'est pas renseigné, le Maître du Jeu est affecté aléatoirement à une table vide de la séance. Si la table est renseignée, le programme s'assure qu'il n'y a pas déjà un Maître du Jeu à cette table. Si tout est valide, la \texttt{TableJeu} choisie est enrichie avec le \texttt{MaitreJeu} et le scénario.
    
    \item \texttt{résilier\_table(TableJeu)}~: Si le Maître du Jeu n'est pas en charge de la table choisie, cela renvoie un message d'erreur. Sinon la \texttt{TableJeu} perd son \texttt{MaitreJeu}, son scénario et tous ses \texttt{Joueurs}.
    
    \item \texttt{voir\_table\_geree(TableJeu)}~: elle prend un numéro de table en paramètre et affiche la liste des Joueurs de la table, leurs personnages et leurs niveaux si l'utilisateur est bien Maître du Jeu de la table. Dans le cas contraire, un message d'erreur apparaît.
\end{itemize}





\subsection{Couche DAO et base de données}

La couche DAO (Data Access Object) permet de faire le lien entre notre application et la base de données PostrgreSQL sur laquelle sont sauvegardées les données.

% Diagramme de base de données







%-------------------------------------------------------------------------------
% Conclusion
%-------------------------------------------------------------------------------

% PAS DE CONCLUSION...

% \section*{Conclusion}
% \addcontentsline{toc}{section}{Conclusion}


%-------------------------------------------------------------------------------
% Annexes
%-------------------------------------------------------------------------------

\newgeometry{top=0.5cm, bottom=0.1cm}

\addcontentsline{toc}{section}{Annexes}
\appendix  % On passe aux annexes
\section*{Annexe 1 - Diagramme de classe UML}


\begin{figure}[H]
    \label{UML_classes}
    \centering
    \includegraphics[angle=90,height=0.9\textheight]{UML_diagrammes/diag_classes.png}
\end{figure}


\restoregeometry


\end{document}

