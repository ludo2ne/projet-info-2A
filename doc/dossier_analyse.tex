\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{multirow}
\usepackage{amsmath,amssymb}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{awesomebox}
\usepackage{tcolorbox}
\usepackage{xcolor}
\usepackage{pifont}
\usepackage[top=1.5cm,bottom=1.5cm,margin=2.5cm]{geometry}


\graphicspath{{Images/}} %le chemin vers les images

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}


%-------------------------------------------------------------------------------
% Page de garde
%-------------------------------------------------------------------------------

\begin{titlepage}
\begin{center}


\textsc{{\LARGE Ecole nationale de la statistique \\et de l'analyse de l'information}} \\ %Nom de l'école
\vspace{5mm}
\includegraphics[width=0.4\textwidth]{ensai_logo}\\[2 cm] %logo de l'école

%\textsc{\LARGE Projet de traitement de données }\\[0.5cm] % Nom de cours


% Title
\HRule \\[0.4cm]
{ \huge \bfseries Projet informatique \\ \ \\ Dossier d'analyse}\\[0.4cm]

\HRule \\[1cm]

{\Large 2ème Année}\\ [2cm]

% Auteur(s) et Superviseur(s)

\begin{flushleft} \Large
\emph{Etudiants :}\\
Ludovic \textsc{Deneuville} \\
Jean-François \textsc{Parriaud} \\
Jason \textsc{Torres} \\
Hugo \textsc{Wispelaere} \\
Banruo \textsc{Zhang} \\
\end{flushleft}

\begin{flushright} \Large
\emph{Professeur:} \\
Rémi \textsc{Pépin} \\
\emph{Encadrant:} \\
Cyriel \textsc{Mallart} \\
\end{flushright}


\vfill
{\large 2022 - 2023}
\end{center}
\end{titlepage} 


%-------------------------------------------------------------------------------
% Table des matieres
%-------------------------------------------------------------------------------

\renewcommand{\contentsname}{Sommaire}
\tableofcontents
\newpage


%-------------------------------------------------------------------------------
% Introduction
%-------------------------------------------------------------------------------

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

Les participants à un événement se divisent en deux catégories: les intervenants et le public. Dans le cadre d'une conférence, le nombre d'intervenants (les conférenciers) est fixé par avance et n'est pas destiné à évoluer, sauf cas de force majeure. Le nombre de personnes dans le public (l'auditoire) se gère de façon relativement linéaire (inscriptions, désistements éventuels). Il est indépendant du nombre d'intervenants et il n'est pas nécessaire de gérer sa répartition.\\

L'organisation d'une convention est différente. En effet les intervenants ne sont pas engagés mais volontaires. Ils doivent pouvoir s'inscrire ou se désister librement et chaque intervenant a la charge de quelques membres du public. Par conséquent, le public ne peut s'inscrire qu'à condition qu'il y ait des intervenants pour les encadrer, ce qui signifie qu'il faut pouvoir gérer son effectif et sa répartition. Le but de notre application est de faciliter l'organisation d'une telle convention. \\



\newpage

%-------------------------------------------------------------------------------
% Section 1
%-------------------------------------------------------------------------------

\section{Analyse du besoin}

\subsection{Cahier des charges}
Notre application devra être utilisable aussi bien par les organisateurs de la convention que par les intervenants et le public.  \\

La convention que notre application doit permettre de gérer se déroule sur un week-end et comporte quatre plages horaires, chacune correspondant à une demi-journée. Elle est dédiée aux jeux de rôle, aussi les intervenants seront par la suite appelés "Maîtres du Jeu" ou MJ. Le public venant quant à lui pour jouer, ses membres seront appelés "Joueurs".\\ 

L'application permettra à quiconque le souhaite de s'inscrire en tant que Joueur. Les Joueurs auront accès à plusieurs fonctionnalités. La première d'entre elles sera la création de personnages, dans une limite de trois, via une API à l'adresse \textcolor{blue}{\href{https://www.dnd5eapi.co/}{https://www.dnd5eapi.co/}}. La détention de personnages autorisera le choix d'une table de jeu par demi-journée. Afin de pouvoir faire un choix éclairé, les Joueurs pourront visualiser, pour chaque table ouverte et disponible, le scénario proposé et ainsi choisir le personnage adéquat. Les Joueurs pourront aussi visualiser un sommaire de leur participation et, le cas échéant, se désister d'une table, ce qui sera automatiquement notifié aux organisateurs.\\

L'application permettra aux Joueurs le désirant de s'inscrire en tant que Maîtres du Jeu. Ceux-ci auront la possibilité, pour chaque demi-journée, de choisir une table  et de définir le scénario proposé à cette table, offrant ainsi à quatre Joueurs la possibilité de s'inscrire à cette table. Ils pourront aussi visualiser les profils des Joueurs inscrits à leur table, afin de mieux préparer leur intervention. En outre, ils auront aussi la possibilité de voir un sommaire de leur participation. Enfin, si nécessaire, ils pourront se désister, entraînant une notification aux organisateurs. Les organisateurs auront alors la charge d'affecter les Joueurs à une autre table dans la mesure du possible, ou d'annuler leur participation à cette demi-journée si nécessaire.\\

\indent Il a été envisagé de différencier totalement les profils Joueur et Maître du Jeu, en leur attribuant des comptes séparés pour une même personne physique. Cela présentait deux inconvénients:
\begin{itemize}
\item{compliquer la gestion des erreurs humaines. En effet, une même personne ne peut pas physiquement participer à deux tables en même temps. Pour chaque compte nous pourrons avoir accès à une liste des tables auxquelles la personne participe. Avoir les comptes Joueur et Maître du Jeu joints signifie la présence d'une unique liste de tables à vérifier. Des comptes séparés auraient entraîné la création de deux listes séparées et, par conséquent, la nécessité de systématiquement vérifier si un compte Maître du Jeu est détenu par une personne ayant aussi un compte Joueur et vice-versa.}
\item{compliquer l'utilisation de l'application pour une personne désirant être à la fois Maître du Jeu et Joueur. En effet, cette personne aurait dû systématiquement se déconnecter et s'authentifier pour passer d'un compte à l'autre.\\}
\end{itemize}

Enfin, les organisateurs auront un profil spécifique, permettant de visualiser un sommaire global de l'activité sur la convention. L'envoi automatique de notification lors de désistement de Joueurs ou de Maîtres du Jeu leur permettra d'être toujours avertis des changements intervenus. Ils seront en mesure de modifier ou supprimer la participation d'un Maître du jeu ou d'un Joueur, entraînant une notification aux personnes concernées.\\

Un système sommaire d'accès par identifiant sera mis en place, par souci de simplicité. Il permettra à la fois de différencier les statuts des protagonistes et de cloisonner les profils individuels. Il sera toujours possible par la suite de mettre en place un système plus sécurisé avec mot de passe. \\



\subsection{Fonctionnalités attendues}

Le diagramme de cas d'utilisation est montré en figure \ref{UML_classe_pipeline}. \\

On désigne par «~Utilisateur~» toute personne lançant l'application. Un Utilisateur, lorsqu'il lance le programme a trois actions à sa disposition~:
\begin{itemize}
    \item{S'inscrire~: l'Utilisateur peut se créer un compte Joueur. Il devra alors donner quelques renseignements sur son identité (nom, prénom, mail, pseudo...) avant de se voir attribuer un identifiant.}
    \item{S'authentifier~: Si l'Utilisateur possède déjà un compte avec un profil Joueur ou Organisateur, il devra indiquer son pseudo pour avoir accès aux fonctionnalités liées à son profil. Dans le cadre de ce projet aucun mot de passe n'est nécessaire pour se connecter.}
    \item{Quitter~:  Fermer l'application.\\}
\end{itemize}

Les organisateurs ont le choix entre les cinq actions suivantes~:
\begin{itemize}
    \item {Déplacer joueur~: lorsque plusieurs tables comptent un trop faible nombre de Joueurs, ou lorsqu'un Maître du Jeu s'est désisté, l'organisateur peut placer les Joueurs sur d'autres tables. Dans ce cas, le Joueur est notifié de ce changement par un message qui s'affichera lors de sa prochaine connexion.}
    \item{Supprimer joueur~: dans le même cas de figure que précédemment, l'organisateur peut annuler la participation du Joueur sur une demi-journée. Cela donne aussi lieu à notification.}
    \item{Ajouter/supprimer table~: si de nombreuses tables sont complètes, les organisateurs ont la possibilité de créer de nouvelles tables. À l'inverse ils peuvent supprimer une table. pour être supprimée, une table doit être vide, c'est à dire que les organisateurs doivent éventuellement exclure au préalable les Joueurs et le Maître du Jeu assis à cette table.}
    \item{Voir programme complet~: l'organisateur peut visualiser sur l'ensemble de la conférence la liste de toutes les tables, avec le scénario, les identités du Maître du Jeu et des Joueurs.}
    \item{Se déconnecter~: l'organisateur met fin à sa session et redevient Utilisateur du point de vue de l'application.\\}
\end{itemize}

Les Joueurs ont le choix entre six actions~:
\begin{itemize}
    \item {Se déconnecter~: le Joueur met fin à sa session et redevient Utilisateur du point de vue de l'application.}
    \item{Voir messages~: le Joueur a accès aux notifications qui lui ont été envoyées. Par exemple celles qui concernent un changement sur son emploi du temps.}
    \item{Créer/supprimer personnage~: le Joueur peut créer un personnage via l'API mentionnée précédemment. Il peut aussi supprimer ce personnage dans la base de données.}
    \item{Rejoindre/quitter table~: le Joueur peut choisir de jouer sur une table. Il pourra alors visualiser les tables ouvertes par les Maîtres du Jeu et les scénarios proposés et indiquera le personnage qu'il incarnera sur cette table. Il peut aussi quitter une table sur laquelle il s'était auparavant inscrit.}
    \item{Voir programme~: le Joueur peut visualiser toutes les tables auxquelles il participe, sur l'ensemble de la conférence.}
    \item{Devenir maître du jeu: le Joueur peut s'inscrire en tant que Maître du Jeu.\\}
\end{itemize}

Un Joueur inscrit comme Maître du Jeu accède à deux fonctionnalités supplémentaires:
\begin{itemize}
    \item{Gérer une table~: il pourra voir les tables disponibles mais non ouvertes par un autre Maître du Jeu, en choisir une, et indiquer le scénario qu'il prévoit pour cette table, avec éventuellement des recommandations concernant les niveaux des personnages des Joueurs.}
    \item{Voir joueurs d'une table~: il aura accès aux informations concernant les Joueurs des tables sur lesquelles il officie, ainsi que leurs personnages.\\}
\end{itemize}

\begin{figure}[H]
    \caption{\textbf{Diagramme de cas d'utilisation}}
    \label{UML_classe_pipeline}
    \centering
    \includegraphics[height=0.9\textheight]{UML_diagrammes/diag_cas_utilisation.png}
\end{figure}


\subsection{Organisation d'équipe}

Lors du démarrage de notre projet, nous avons évoqué plusieurs sujets importants pour une organisation d'équipe efficace et une bonne entente. Le premier sujet évoqué concerne les règles de vie dans notre équipe. Chacun des membres devra respecter les autres, communiquer, être solidaire, être force de proposition, anticiper et ne pas travailler à la dernière minute.


\bigbreak

Ensuite nous avons parlé de la liste de nos compétences et appétences par rapport aux besoins sur ce projet (connaissances en informatique, python, base de données, rédaction...). Ainsi nous nous sommes répartis les rôles suivants:
\begin{itemize}
    \item{Chef de projet~: Suivi du projet, organisation, vérification que chacun sait ce qu’il doit faire}
    \item{Responsable de la communication~: s'occupe de la communication avec les intervenants externes}
    \item{Maître du temps~: s’assure que les délais sont bien respectés}
    \item{Expert technique~: Assiste les développeurs en cas de problème technique}
    \item{Rédacteur en chef~: Valide les rapports, s'occupe de la mise en forme, corrige les fautes}
\end{itemize}

Nous avons également convenu que tous les membres de l'équipe participeront au développement du code.

\bigbreak

Nous allons utiliser divers outils pour répondre à des besoins concernant différents aspects de ce projet :
\begin{itemize}
    \item{Suivi et communication~: \href{https://hackmd.io/CMTCDVW6Spe2PHXOhdKTRQ}{hackMd}, Discord}
    \item{Analyse~: PlantUML}
    \item{Développement~: python (sur Visual Studio Code), PostgreSQL DBeaver, fastApi}
    \item{Gestion de version~: Git, GitHub}
    \item{Rédaction~: LateX}
\end{itemize}


\bigbreak

Le diagramme de Gantt relatif à l'organisation de notre équipe est montré en figure \ref{UML_gantt}.\\

La première strate concerne les Livrables, c-a-d les échéances à respecter. Par exemple, le présent dossier d'analyse est à rendre le 8 Octobre.\\

La seconde strate concerne les Rendez-Vous, qui incluent les séances supervisées et les réunions in situ, nommées "Team meeting". Ces dernières permettent de faire le point entre nous sur des tâches clés qui auront un fort impact sur le développement de l'application après que chacun ait pris le temps d'y réfléchir séparément. Elles dépendent de l'avancement du projet et sont fixées à courte échéance. Entre temps, la communication du groupe s'opère via la plate-forme Discord, sur laquelle un serveur dédié à notre projet a été mis en place.\\

\begin{figure}[H]
    \caption{\textbf{Diagramme de Gantt}}
    \label{UML_gantt}
    \centering
    \includegraphics[height=0.5\textheight]{UML_diagrammes/DiagGantt.png}
\end{figure}

La troisième strate illustre les différentes phases du projet. Les six premières semaines sont consacrées à l'étude et à la conception du projet, incluant la réalisation des diagrammes présentés dans ce dossier et la documentation. Pendant ce temps, les cours et TP nécessaires à la réalisation concrète de l'application (Programmation Orientée Objet, Webservices, Git) peuvent avoir lieu. La phase de développement, incluant le codage de l'application et la mise en place de la base de données, se déroulera ensuite sur une période d'environ six semaines. Lorsque cette phase sera bien avancée, la rédaction d'un rapport final pourra débuter, suivie par la préparation de la présentation de notre travail lors de la soutenance.\\

La dernière strate montre les tâches concrètes à réaliser et est complétée au fur et à mesure.\\





%-------------------------------------------------------------------------------
% Section 2
%-------------------------------------------------------------------------------

\newpage
\section{Conception}

\subsection{Modélisation}

L'application sera découpée en trois couches :
\begin{itemize}
    \item \texttt{Couche de Présentation} : elle contiendra les classes qui gèrent l'interface avec l'utilisateur,
    \item \texttt{Couche de Service} : elle regroupe les classes qui contiennent les procédures métier,
    \item \texttt{Couche DAO} : ensemble de classes permettant d'accéder à la base de données.
\end{itemize}

\bigbreak

Les objets métier seront regroupés dans un package nommé business\_objects.

\subsection{La couche Vue}

Les classes de la couche vue sont des classes d'interface avec l'utilisateur. Elles affichent les fonctionnalités disponibles. La modélisation de ces classes est ainsi semblable au diagramme de cas d'utilisation présenté précédemment.

\bigbreak

Lorsque l'application se lance, l'utilisateur va être dirigé vers la vue \texttt{AccueilVue}. Il aura la possibilité de se créer un compte, de se connecter ou de quitter. Ensuite selon le choix effectué, l'utilisateur sera dirigé vers une nouvelle vue. Tant que la personne n'a pas choisi de quitter l'application, elle va naviguer de vue en vue. Dans la majorité des cas, une vue devra appeler des services. Ceux-ci effectueront les traitements métier demandés.


\subsection{Les objets métier}

Afin de modéliser notre application, nous avons listé les objets dont nous avions besoin (voir diagramme ci-dessous).


\textcolor{red}{TODO : décrire pourquoi on a choisi tel objet, tel attribut}



\subsection{La couche Service}

La couche service est le coeur de notre application. Elle contient toutes les méthodes qui permettent de répondre aux besoins des utilisateurs.



\textcolor{red}{TODO : décrire les méthodes des classes Service}


\bigbreak


La classe \texttt{OrganisateurService} possède les trois méthodes suivantes :
\begin{itemize}[label=\ding{109}, font=\small]
    \item \texttt{creer\_table()}~: 
    \item \texttt{supprimer\_table()}~: 
    \item \texttt{supprimer\_joueur()}~: 
    \item \texttt{deplacer\_joueur()}~: 
    \item \texttt{voir\_programme\_complet()}~: 
\end{itemize}

\bigbreak

La classe \texttt{JoueurService} possède les trois méthodes suivantes :
\begin{itemize}[label=\ding{109}, font=\small]
    \item \texttt{creer()}~: 
    \item \texttt{supprimer()}~: 
    \item \texttt{creer\_personnage()}~: 
    \item \texttt{supprimer\_personnage()}~: 
    \item \texttt{lister\_personnage()}~: 
    \item \texttt{voir\_tables()}~: 
    \item \texttt{rejoindre\_table()}~: 
    \item \texttt{quitter\_table()}~: 
\end{itemize}


\bigbreak


La classe \texttt{MaitreJeuService} possède les méthodes suivantes :

\begin{itemize}[label=\ding{109}, font=\small]
    \item \texttt{gerer\_table()}~: elle prend trois paramètres : un numéro de séance, une \texttt{TableJeu} et une chaîne de caractères contenant la description du scénario. En premier lieu, une vérification est faite sur la disponibilité du maître du jeu. S'il n'est pas disponible, un message d'erreur est retourné. Le paramètre \texttt{TableJeu} est optionnel, s'il n'est pas renseigné, le maître du jeu est affecté aléatoirement à une table vide de la séance. Si tout est valide, la \texttt{TableJeu} choisie est enrichie avec le \texttt{MaitreJeu} et le scénario.
    
    \item \texttt{resilier\_table()}~: Cette méthode prend en paramètre un numéro de table. Si le maître du jeu n'est pas en charge de la table choisie, cela renvoie un message d'erreur. Sinon la \texttt{TableJeu} perd son \texttt{MaitreJeu}, son scénario et tous ses \texttt{Joueurs}.
    
    \item \texttt{voir\_joueur()}~: elle prend un numéro de table en paramètre et affiche la liste des joueurs de la table, leurs personnages et leurs niveaux si l'utilisateur est bien maître du jeu de la table. Dans le cas contraire, un message d'erreur apparait.
\end{itemize}





\subsection{Couche DAO et base de données}

La couche DAO (Data Access Object) permet de faire le lien entre notre application et la base de données PostrgreSQL sur laquelle sont sauvegardées les données.

% Diagramme de base de données




\newpage




%-------------------------------------------------------------------------------
% Conclusion
%-------------------------------------------------------------------------------

% PAS DE CONCLUSION...

% \section*{Conclusion}
% \addcontentsline{toc}{section}{Conclusion}


%-------------------------------------------------------------------------------
% Annexes
%-------------------------------------------------------------------------------


\newpage
\addcontentsline{toc}{section}{Annexes}
\appendix  % On passe aux annexes
\section*{Annexe 1 - Diagramme de classe UML}


ggg



\newpage

\section*{Annexe 2 - Utilisation de Git sur notre projet}

\textcolor{red}{Ludo : je vais supprimer cet annexe mais je laisse pour l'instant si vous voulez voir comment on fonctionne avec Git sur un projet}


Git est un logiciel de gestion de versions. Il facilite, pour chaque développeur, la synchronisation entre le dépôt local (le code qui est sur notre ordinateur) et le dépôt distant sur GitHub (le code commun). Il est ainsi beaucoup plus simple de travailler sur un même projet et d'éviter les décalages de versions. Dans le cadre de notre projet, nous utiliserons les fonctionnalités basiques de Git. Nous avons mis en place le protocole ci-dessous.

\bigbreak

Notre dépôt est organisé avec les dossiers suivants :
\begin{itemize}
    \item src : contient les fichiers python
    \item doc : fichiers de documentation (cahier des charges, diagrammes UML...)
    \item donnees : contient des fichiers de données, des fichiers tests et un dossier \texttt{exports} où seront générés tous les exports. 
\end{itemize}


\subsection*{Avant de commencer à coder}

\begin{itemize}
    \item Dans Visual Studio Code, j'ouvre un terminal Git Bash
    \item Menu View > Terminal (ou CTRL+ù)
    \item je clique sur la petite flèche vers le bas à coté du +, puis sur Git Bash
    \item Normalement je suis placé directement dans le bon dossier et dans la console s'affiche : 
\end{itemize}


\noindent
\verb"idxxxx yyyyyy /p/projet-info-sources/Projet-info (main)" \\
\verb"git pull      # permet de mettre à jour le dépôt local avec le dépôt distant"




\subsection*{Je code}

\begin{itemize}
    \item je crée/modifie/supprime des fichiers python (ou autre)
    \item je teste que ça fonctionne bien
    \item une fois que j'ai un morceau de code qui fonctionne, je crée un \textbf{commit} (point de sauvegarde)
    \item il est très important de faire régulièrement un commit dès que quelque chose fonctionne bien. Cela évitera de perdre beaucoup de temps si ensuite par une action malheureuse, le code ne fonctionnait plus du tout. Dans ce cas, un simple retour arrière au dernier commit et l'on peut repartir sur de bonnes bases
\end{itemize}

\noindent
\verb"git add .    # permet d'ajouter tous les nouveaux fichiers créés" \\
\verb"git status   # pour voir les changements en cours" \\
\verb"git commit -am «~message explicite~»     # Pour créer un commit" \\

\bigbreak

Si par la suite je fais une erreur, il est facile de revenir en arrière (au dernier commit) :\\
\verb"git reset --hard" 

\bigbreak

Attention cette commande supprime toutes les modifications effectuées depuis le dernier commit. Par sécurité, je crée une copie du dossier \textbf{Projet-info} avant de lancer la commande.



\subsection*{Je partage mon travail}

\begin{itemize}
    \item Si personne n'a poussé du code entre temps, tout va bien, je vais pouvoir faire un \textbf{push}
    \item Par contre si le dépôt distant a été modifié, je dois synchroniser mon dépôt local avec les mises à jour effectuées sur le dépôt distant par d'autres membres de l'équipe
    \item Si vous n'avez pas touché aux mêmes fichiers, Git va effectuer la fusion tout seul lors du \textbf{git pull}
    \item Si vous avez touché au même fichier, ça se complique un peu. Git va dire qu'il n'a pas réussi de fusion automatique (\textit{CONFLICT (content): Merge conflict - Automatic merge failed}). Il faut ouvrir les fichiers en conflit et ceci apparaît : 
\end{itemize}


\noindent
\verb"<<<<<<< HEAD" \\
\verb"« Les modifications que j'ai faites »" \\
\verb"=======" \\
\verb"« Les modifications faites par un autre membre de l'équipe »" \\
\verb">>>>>>>" \\

\begin{itemize}
    \item je modifie le fichier pour choisir quelle modification je garde
    \item je teste et je vérifie que tout est ok
    \item je recrée un commit \verb"git commit -am « merge manuel »"
    \item et enfin, je peux faire \verb"git push"
\end{itemize}

\noindent
\verb"git pull           # pour récupérer les éventuelles modifications du dépôt distant" \\
\verb"git status         # pour voir s'il n'y a pas de conflits" \\
\verb"git push           # pousser son code vers le dépôt distant" \\



\subsection*{Commandes Git : ce qu'il faut retenir}

\noindent
\verb"git status               # Voir ce qui est en cours" \\
\verb"git pull                 # Copier dépôt distant vers dépôt local" \\
\verb"git push                 # Copier dépôt local vers dépôt distant" \\
\verb"git add .                # Avant un commit pour que git identifie les nouveaux fichiers" \\
\verb"git commit -am « message » # Créer un point de sauvegarde" \\
\verb"git diff                 # Avant de faire un commit, voir les différences" \\








\end{document}

