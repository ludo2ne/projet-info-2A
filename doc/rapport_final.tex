\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{multirow}
\usepackage{amsmath,amssymb}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{awesomebox}
\usepackage{tcolorbox}
\usepackage{xcolor}
\usepackage{pifont}
\usepackage[top=1.5cm,bottom=1.5cm,margin=2.5cm]{geometry}



\graphicspath{{Images/}} %le chemin vers les images

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}


%-------------------------------------------------------------------------------
% Page de garde
%-------------------------------------------------------------------------------

\begin{titlepage}
\begin{center}


\textsc{{\LARGE Ecole nationale de la statistique \\et de l'analyse de l'information}} \\ %Nom de l'école
\vspace{5mm}
\includegraphics[width=0.4\textwidth]{ensai_logo}\\[2 cm] %logo de l'école

%\textsc{\LARGE Projet de traitement de données }\\[0.5cm] % Nom de cours


% Title
\HRule \\[0.4cm]
{ \huge \bfseries Projet informatique \\ \ \\ Rapport final}\\[0.4cm]

\HRule \\[1cm]

{\Large 2ème Année}\\ [2cm]

% Auteur(s) et Superviseur(s)

\begin{flushleft} \Large
\emph{Etudiants :}\\
Ludovic \textsc{Deneuville} \\
Jean-François \textsc{Parriaud} \\
Jason \textsc{Torres} \\
Hugo \textsc{Wispelaere} \\
Banruo \textsc{Zhang} \\
\end{flushleft}

\begin{flushright} \Large
\emph{Professeur:} \\
Rémi \textsc{Pépin} \\
\emph{Encadrant:} \\
Cyriel \textsc{Mallart} \\
\end{flushright}


\vfill
{\large 2022 - 2023}
\end{center}
\end{titlepage} 


%-------------------------------------------------------------------------------
% Table des matieres
%-------------------------------------------------------------------------------

\renewcommand{\contentsname}{Sommaire}
\tableofcontents
\newpage


%-------------------------------------------------------------------------------
% Introduction
%-------------------------------------------------------------------------------

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

Les personnes impliquées dans un événement public se divisent en trois catégories: les organisateurs, les intervenants et le public. Dans le cadre d'une conférence, les intervenants (les conférenciers) sont choisis par les organisateurs. Leur nombre est fixé par avance en fonction de plusieurs critères: contraintes horaires, salles disponibles, budget, et ce nombre n'est pas destiné à évoluer, sauf cas de force majeure tel un désistement. Les organisateurs gèrent le nombre de personnes dans le public (l'auditoire) de façon relativement linéaire (inscriptions, désistements éventuels). Le nombre de personnes dans le public n'est pas limité par le nombre d'intervenants mais par les capacités d'accueil des salles. Ainsi, il est possible d'accueillir des personnes sans réservation dans la limites des places disponibles et il n'est pas nécessaire de gérer la répartition de l'auditoire.\\

L'organisation d'une convention est différente. En effet les intervenants ne sont pas engagés par les organisateurs mais sont des volontaires, oeuvrant bénévolement pour partager leur passion. Ils doivent pouvoir s'inscrire ou se désister librement et chaque intervenant a la charge de quelques membres du public. Par conséquent, le public ne peut s'inscrire qu'à condition qu'il y ait des intervenants pour les encadrer (en pratique, les organisateurs auront tendance à faire la promotion de leur convention auprès de communautés susceptibles de fournir des intervenants avant de lancer la phase d'inscription). Il faut par conséquent pouvoir gérer son effectif et sa répartition au fil de l'eau en fonction du nombre d'intervenants disponibles et des capacités d'accueil de la salle. Toutes ces contraintes font que l'organisation d'une convention est complexe et notre but est de fournir un outil approprié sous forme d'application. \\



\newpage

%-------------------------------------------------------------------------------
% Section 1
%-------------------------------------------------------------------------------

\section{Analyse du besoin}


\subsection{Cahier des charges}
L'objectif de ce projet est de développer une application qui permette de gérer l'organisation d'une convention. Cette application devra être utilisable aussi bien par les organisateurs que par les intervenants et le public.  \\

Nous nous sommes basés sur le principe d'une convention se déroulant sur un week-end et comportant quatre plages horaires, chacune correspondant à une demi-journée. Cette convention est dédiée aux jeux de rôle, aussi les intervenants seront par la suite appelés «~Maîtres du Jeu~» ou MJ. Le public venant quant à lui pour jouer, ses membres seront appelés «~Joueurs~».\\ 

L'application doit permettre aux Joueurs de planifier leur week-end en participant à un jeu par séance au maximum. De même les Maîtres du Jeu doivent pouvoir planifier leur intervention. Il devra être possible de participer à la fois en tant que Joueur et en tant que Maître du Jeu sur des séances différentes puisqu'il est impossible de jouer à une table et de gérer une autre table en même temps.\\

Enfin les organisateurs doivent pouvoir gérer l'organisation de la convention, que ce soit en termes de matériels ou de ressources humaines, ce qui nécessite de disposer d'informations au moindre problème.\\




\subsection{Fonctionnalités attendues de l'application}


L'application permettra à tout utilisateur de s'inscrire en tant que Joueur. Lorsqu'il joue, le Joueur incarne un personnage de sa composition. Aussi la première fonctionnalité disponible pour un Joueur sera la création de personnages, dans une limite de trois. Un appel à l'API suivante \textcolor{blue}{\href{https://www.dnd5eapi.co/}{https://www.dnd5eapi.co/}} permettra de compléter les informations sur les personnages. La détention de personnages permettra au Joueur de s'asseoir à une table par demi-journée. C'est là qu'intervient la deuxième fonctionnalité: l'inscription à une table. Afin de pouvoir faire un choix éclairé, les Joueurs pourront visualiser, pour chaque table ouverte et disponible, le scénario proposé et ainsi choisir le personnage adéquat. Les Joueurs pourront aussi visualiser un sommaire de leur participation et, le cas échéant, se désister d'une table, ce qui sera automatiquement notifié aux organisateurs.\\

L'application permettra aux Joueurs le désirant de s'inscrire en tant que Maîtres du Jeu et d'accéder ainsi à des fonctionnalités spécifiques. Les Maîtres du Jeu auront en premier lieu la possibilité, pour chaque demi-journée, de choisir une table à gérer et d'en définir le scénario. Ce faisant, ils offriront à cinq Joueurs la possibilité de s'inscrire à leur table. En second lieu, ils pourront visualiser un sommaire de leur participation avec les profils des Joueurs inscrits à leur table, afin de peaufiner leur intervention. Enfin, si nécessaire, ils pourront se désister, entraînant une notification aux organisateurs. Les organisateurs auront alors la charge d'affecter les Joueurs à une autre table dans la mesure du possible, ou d'annuler leur participation à cette demi-journée si nécessaire.\\

\indent Il a été envisagé de différencier totalement les profils Joueur et Maître du Jeu, en leur attribuant des comptes séparés pour une même personne physique. Cela présentait deux inconvénients:
\begin{itemize}
\item{compliquer la gestion des erreurs humaines. En effet, une même personne ne peut pas physiquement participer à deux tables en même temps. Pour chaque compte nous pourrons avoir accès à une liste des tables auxquelles la personne participe. Avoir les comptes Joueur et Maître du Jeu joints signifie la présence d'une unique liste de tables à vérifier. Des comptes séparés auraient entraîné la création de deux listes séparées et, par conséquent, la nécessité de systématiquement vérifier si un compte Maître du Jeu est détenu par une personne ayant aussi un compte Joueur et vice-versa.}
\item{compliquer l'utilisation de l'application pour une personne désirant être à la fois Maître du Jeu et Joueur. En effet, cette personne aurait dû systématiquement se déconnecter et s'authentifier pour passer d'un compte à l'autre.\\}
\end{itemize}

Enfin, les organisateurs de la convention auront un profil spécifique. Du point de vue de l'application, ils seront considérés comme Administrateurs et pourront visualiser un sommaire global de l'activité sur la convention. L'envoi automatique de notifications lors de désistements de Joueurs ou de Maîtres du Jeu et la possibilité de les consulter dans leur messagerie leur permettra d'être toujours avertis des changements intervenus. Ils seront en mesure de modifier ou supprimer la participation d'un Maître du jeu ou d'un Joueur, entraînant une notification aux personnes concernées. Enfin, ils auront la possibilité de supprimer ou rajouter des tables selon les besoins.\\

Un système sommaire d'accès par pseudo sera mis en place, par souci de simplicité. Il permettra à la fois de différencier les statuts des protagonistes et de cloisonner les profils individuels. Il sera toujours possible par la suite de mettre en place un système plus sécurisé avec mot de passe. \\
%-------------------------------------------------------------------------------
% Section 2
%-------------------------------------------------------------------------------

\newpage
\section{Diagramme de Gantt et organisation de l'équipe}
Lors du démarrage de notre projet, nous avons évoqué plusieurs sujets importants pour une organisation d'équipe efficace et une bonne entente. Le premier sujet évoqué concerne les règles de vie dans notre équipe. Chacun des membres devra respecter les autres, communiquer, être solidaire, être force de proposition, anticiper et ne pas travailler à la dernière minute.


\bigbreak

Ensuite nous avons parlé de la liste de nos compétences et appétences par rapport aux besoins sur ce projet (connaissances en informatique, python, base de données, organisation, rédaction...). Ainsi nous nous sommes répartis les rôles suivants:
\begin{itemize}
    \item{Chef de projet~: suivi du projet, organisation, vérification que chacun sait ce qu’il doit faire}
    \item{Responsable de la communication~: s'occupe de la communication avec les intervenants externes}
    \item{Maître du temps~: s’assure que les délais sont bien respectés}
    \item{Expert technique~: assiste les développeurs en cas de problème technique}
    \item{Rédacteur en chef~: Valide les rapports, s'occupe de la mise en forme, corrige les fautes}
\end{itemize}

Nous avons également convenu que tous les membres de l'équipe participeront au développement de l'application.

\bigbreak

Nous utiliserons les outils suivants pour répondre à des besoins concernant différents aspects de ce projet :
\begin{itemize}
    \item{Suivi et communication~: \href{https://hackmd.io/CMTCDVW6Spe2PHXOhdKTRQ}{HackMd}, Discord}
    \item{Analyse et Rédaction~: PlantUML, LateX}
    \item{Développement~: Python, Visual Studio Code, PostgreSQL, DBeaver}
    \item{Gestion de version~: Git, GitHub}
\end{itemize}


\bigbreak

Le diagramme de Gantt relatif à l'organisation de notre équipe est montré en figure \ref{UML_gantt}.\\


\begin{figure}[H]
    \caption{\textbf{Diagramme de Gantt}}
    \label{UML_gantt}
    \centering
    \includegraphics[height=0.35\textheight]{UML_diagrammes/diag_gantt.png}
\end{figure}

Les deux premières strates listent les rendez-vous et les échéances importantes. \\

La troisième strate illustre les différentes phases du projet. Les six premières semaines ont été consacrées à l'étude et à la conception du projet, incluant la réalisation des diagrammes présentés dans ce dossier et la documentation. Pendant ce temps, les cours et TP nécessaires à la réalisation concrète de l'application (Programmation Orientée Objet, Webservices, Git) ont pu avoir lieu. La phase de développement, incluant le codage de l'application et la mise en place de la base de données, s'est ensuite déroulée sur une période d'environ six semaines. \\

La dernière strate montre les tâches concrètes à réaliser et est complétée au fur et à mesure.\\

Lorsque la dernière phase a été entamée, la rédaction du rapport a pu commencer. 
En ce qui concerne l’implémentation du code, une répartition a été réalisée en fonction du niveau de chacun. Les classes les plus accessibles comme les classes de vue ont été réalisées par les membres du groupe les moins à l’aise. Tandis que les classes de service qui ont été bien plus difficiles à implémenter ont été codées par les membres les plus à l’aise du groupe. Les trois jours dédiés au projet ont permis d’aboutir à 90\% du code final. \\

Puis au retour des vacances, le plan du rapport final a été élaboré conjointement. Chaque proposition a été étudiée et prise en considération si le groupe la trouvait pertinente. Une concertation de quelques heures a permis d’aboutir au plan final du rapport. Concernant la rédaction de ce dernier, tous les membres ont pris en charge plusieurs sous-parties.


%-------------------------------------------------------------------------------
% Section 3
%-------------------------------------------------------------------------------

\newpage
\section{Modélisation}

\subsection{Les couches}

Nous avons découpé l'application en trois couches principales : la couche de Vue, la couche de Service, et la couche DAO (Data Access Object), afin de garantir une structure claire pour le processus de création de l'application. Tout en regroupant les exigences de l'application en fonction des couches, nous avons également évité les fonctionnalités manquantes. De plus, cela nous permet également de diviser les tâches en unités plus petites lors de leur attribution afin de faciliter le travail en équipe.

\begin{itemize}
    \item \texttt{la couche de Vue}~: elle contient le module qui implémente l'interface par laquelle l'utilisateur accède à l'application, permettant ainsi à l'utilisateur d'accéder à diverses fonctionnalités. L'interface utilisateur de notre application est contenue dans un terminal.
    \item \texttt{la couche de Service}~:  elle est le coeur de notre application, qui contient toutes les méthodes qui permettront ensuite de répondre aux besoins des utilisateurs.
    \item \texttt{la couche DAO}~:  elle contient des modules qui peuvent accéder à la base de données. Pour la persistance des données, nous avons choisi de sauvegarder nos données sur une base de données. Nous utiliserons le système de gestion de base de données relationnelle PostgreSQL.\\
\end{itemize}

Lorsque l'application est en cours d'exécution, une fois que l'utilisateur a formulé une demande, celle-ci est prise en charge par la couche de Vue et transmise à la couche Service. La couche Service traite la demande du client et, lorsqu'un accès à la base de données est nécessaire, elle transmet la demande à la couche DAO. La couche DAO relie la base de données en envoyant la requête et renvoie le résultat à la couche Service, qui transmet à la couche de Vue, laquelle présente le résultat à l'utilisateur.\\

La couche DAO, disponible en annexe en figure \ref{UML_classes}, proposera diverses classes et méthodes qui permettront de communiquer avec la base de données. Les classes de notre DAO s'appuieront sur les différentes opérations du \textbf{CRUD} (Create Read Update Delete) et proposeront une liste exhaustive de méthodes d'interactions avec la base de données. Parmi celles-ci, il y a la classe \textbf{DBconnection} qui se chargera de gérer les connexions à la base de données. Afin de ne pas nous retrouver avec des centaines de connexions qui compromettraient l'efficacité de notre application, nous avons choisi de conceptualiser cette classe à partir du \textbf{design pattern} Singleton. La classe DBconnection héritera de la méta-classe \textbf{Singleton} qui assurera l'instanciation unique de cette classe.



\subsection{Les objets métier}

La création d’objets métiers a été nécessaire dans la programmation en couche. Pour rappel, ces classes ne disposent que d’attributs et pas de méthodes. Elles permettent de créer les objets/utilisateurs de la séance qui seront utilisés dans la modération de la conférence. Ces objets représentent le cœur de la problématique de la conférence puisqu’ils seront utilisés par l’ensemble des autres couches de l’application. C’est pourquoi nous avons créé les sept objets suivants qui seront constamment appelés dans diverses classes du code:

\bigbreak

\begin{itemize}
    \item \texttt{Administrateur}~: c'est l'un des organisateurs de la convention, il n’est pas considéré comme Joueur. Cette classe possède les deux attributs suivants :
    \begin{itemize}[label=\ding{109}, font=\small]
        \item \texttt{id\_admin}~: int, un Administrateur dispose d'un identifiant unique.
        \item \texttt{pseudo}~: str, comme tout membre de la convention de jeu de rôle, un Administrateur dispose d'un pseudo pour se connecter à son profil d'administrateur et accéder aux différentes vues et services dont il dispose.
    \end{itemize}
    
    \item \texttt{Personnage}~: il s'agit d'un personnage fictif de jeu de rôle que crée un Joueur pour participer à une session de jeu. Cette classe possède les attributs suivants :
    \begin{itemize}[label=\ding{109}, font=\small]
        \item \texttt{id\_personnage}~: int, chaque personnage est associé à un identifiant unique.
        \item \texttt{nom}~: str, nom du personnage.
        \item \texttt{classe}~: str, classe du personnage (Guerrier, Druide, Magicien...)
        \item \texttt{race}~: str, race du personnage (Humain, Elfe, Nain...).
        \item \texttt{niveau}~: int, niveau du personnage.
        \item \texttt{competence}~: str, compétence dont le personnage dispose.
        \item \texttt{langue\_parlée}~: str, langue parlée par le personnage.
    \end{itemize}

    \item \texttt{Joueur}~: c'est une personne réelle qui participe à la convention de jeu de rôle en tant que joueur. Cette classe possède les six attributs suivants :
    \begin{itemize}[label=\ding{109}, font=\small]
        \item \texttt{id\_joueur}~: int, identifiant unique du Joueur
        \item \texttt{pseudo}~: str, pseudo à l'aide duquel le Joueur se connecte afin d'accéder aux vues et services qui lui sont propres.
        \item \texttt{nom}~: str, son nom propre, qu'il renseigne lors de l'inscription.
        \item \texttt{prenom}~: str, son prénom, qu'il renseigne lors de l'inscription.
        \item \texttt{mail}~: str, son adresse mail, qu'il renseigne lors de l'inscription.
        \item \texttt{personnages}~: list[Personnage], il s'agit de la liste des personnages que le Joueur souhaite potentiellement utiliser lors de la convention. On limitera le nombre de personnages qu'il peut créer à trois.
    \end{itemize}

    \item \texttt{MaitreJeu}~: c'est une classe qui hérite des attributs de la classe Joueur. Ce qui différencie un Maître du Jeu d'un Joueur réside dans les fonctionnalités dont ils disposent et les vues de chacun (cf couches vues et services). Aucune différenciation n'est faite au niveau des attributs du Joueur et du Maître du Jeu.


    \item \texttt{TableJeu}~: Une Table de Jeu est à distinguer d'une table réelle. Une même table correspondra à des Tables de Jeu différentes entre la séance du matin et celle de l'après-midi. De plus nous avons choisi de nommer cette classe ainsi plutôt que simplement «~Table~» car ce mot aurait pu poser des problèmes en SQL, où c'est un mot clé. Une Table de Jeu possède les cinq attributs suivants :
    \begin{itemize}[label=\ding{109}, font=\small]
        \item \texttt{id\_table}~: int, chaque table dispose d'un  identifiant unique.
        \item \texttt{id\_seance}~: int, numéro de la séance sur laquelle la table est utilisée (1 pour le samedi matin, 2 pour le samedi après-midi, 3 pour le dimanche matin et 4 pour le dimanche après-midi).
        \item \texttt{maitre\_jeu}~: MaîtreJeu, Maître du Jeu qui s'occupe de la Table de Jeu.
        \item \texttt{scenario}~: str, scénario choisi par le Maître du Jeu pour animer la Table de Jeu.
        \item \texttt{personnages}~: list[Personnages], liste des Personnages de la Table de Jeu.
    \end{itemize}

    \item \texttt{Seance}~: Une séance, se déroulant lors de la conférence, est une demi-journée durant laquelle différents joueurs participent au jeu de rôle sur différentes tables. Une séance possède les quatre attributs suivants :
    \begin{itemize}[label=\ding{109}, font=\small]
        \item \texttt{id\_seance}~: int, identifiant unique de la séance.
        \item \texttt{description}~: str, description de la séance.
        \item \texttt{debut}~: date, date de début de la séance .
        \item \texttt{fin}~: date, date de fin de la séance.
    \end{itemize}
    
    \item \texttt{Message}~: Potentiel message reçu par un joueur  :
    \begin{itemize}[label=\ding{109}, font=\small]
        \item \texttt{id\_message}~: int, identifiant unique du message.
        \item \texttt{id\_joueur}~: int, identifiant unique du joueur.
        \item \texttt{date\_creation}~: time, date et heure de la création du message.
        \item \texttt{contenu}~: str, contenu du message.
        \item \texttt{lu}~: bool, indique si le joueur a lu le message.
    \end{itemize}
    
\end{itemize}




\subsection{Diagramme de classes}

TODO mettre à jour \textcolor{red}{Jason} \\
Expliquer au global et prendre un exemple (détailler le cheminement entre les classes d'une fonctionnalité) 
\textcolor{red}{expliquer les héritages!!!} \\

Lors de la conception de notre application, nous devions en amont réfléchir à une structure globale du système qui nous permettrait de mettre en exergue les différentes relations et rôles des classes mais aussi de pouvoir avoir une vision globale de la structure du code que nous aurions à produire.  La tâche qui nous incombait naturellement fut avant tout celle de distinguer les différentes classes et fonctionnalités dont nous avions besoin. Nous devions notamment isoler les différents groupes de classes répondant à un rôle précis. Ces différent groupes ont été mis en évidence dans la section précédente.\\

Cela a abouti à la création du diagramme de classe UML présenté en annexe, figure \ref{UML_classes} \\
Finalement nous avons distingué cinq groupes de classes :

\begin{itemize}
    \item \textbf{business\_objects} \\
    Celle-ci regroupe les classes relatives aux objets métiers présentés à la section précédente.
    \item \textbf{client} \\
    Permet de communiquer avec l'API D\&D 5th Edition  : \href{https://www.dnd5eapi.co/}{https://www.dnd5eapi.co/} et ainsi de récupérer une panoplie de données de variable utilisables pour compléter les attributs des personnages.
    \item \textbf{vue} \\
    Notre groupe de classe \textit{vue} présenté sur le diagramme UML présente un ensemble non exhaustif de classes que nous avons eu à implémenter. Chaque classe permet, entre autres, la gestion des affichages au sein de l'interface utilisateur. Nous avons choisi d'utiliser une commande de vue interactive sur le terminal gérée par le package InquirePy.
    Nous avons choisi de créer une classe abstraite parent \textit{VueAbstraite} dont hériteront toutes les autres classes de Vue, selon le modèle du Bridge Pattern.
    \item \textbf{service} \\
    Celle-ci regroupe l'ensemble des classes permettant l'exécution des différentes fonctionnalités mises à disposition pour l'utilisateur, dépendant de son statut et rôle au sein du système.
    \item \textbf{dao} \\
    Celle-ci finalement réunit l'ensemble des classes permettant d'entrer en interaction avec la base de donnée selon les actions réalisées par les utilisateurs.
\end{itemize}

Voyons en détail la manière dont communiquent les différents groupes de classe de notre système. \textbf{Nous prendrons ici l'exemple d'un joueur souhaitant créer un personnage}. Lors du lancement de l'application, un singleton Session est instancié. Lors de la connexion de l'utilisateur, un objet correspondant à son profil est instancié et placé en attribut de la Session, afin d'avoir accès à l'identité de l'utilisateur à tout moment. Ainsi un joueur est représenté par la classe business object \textit{Joueur}. Le joueur est invité à choisir, parmi les différentes fonctionnalités qui lui sont proposées, celle qu'il souhaite exécuter. Ces fonctionnalités lui sont affichées à travers la classe \textit{JoueurMenuVue}. Après avoir choisi la fonctionnalité \textit{Créer un personnage}, le joueur est redirigé vers la vue \textit{CreerPersonnageVue}. Cette vue demande au joueur de saisir les informations relatives à la création de son personnage. Pour certaines informations (classe, race, compétence et langue), l'application a interrogé une API pour en obtenir la liste. Le joueur en sélectionne une puis l'application se charge d'appeler le service de création de personnage via la méthode \textit{Creer} de la classe \textit{PersonnageService}. Par la suite, cette même méthode fera appel aux services de persistance des données contenu dans la couche DAO, afin d'enregistrer le personnage créé dans la base de données. Le système de persistance est davantage expliqué dans la section qui lui est dédiée.



\subsection{Outils et technologies utilisées}

Lors de ce projet, nous avons découvert et utilisé certains outils qui nous ont aidés pour la phase de réalisation. Nous allons ici détailler quelques-uns de ces outils et les bénéfices obtenus grâce à leur utilisation.

\bigbreak

Une des premières préoccupations avant de commencer à développer est que nous souhaitions avoir des outils configurés de la même manière pour chacun des membres de l'équipe. Cela est important, car si un code fonctionne sur la machine d'un membre et pas sur celle d'un autre, la perte de temps risque d'être importante.


\bigbreak

Nous voulions également éviter que pour l'indentation, certains utilisent des tabulations et d'autres des espaces. Cela serait gênant, si par exemple, nous souhaitions comparer deux versions d'un fichier avec Git, le résultat serait illisible. En effet, pour git une tabulation et quatre espaces ce n'est pas pareil. Pour pallier ce genre de problèmes, nous avons utilisé le package \texttt{autopep8}. Nous avons configuré Visual Studio Code, via le fichier \texttt{setting.json} pour que tous les membres de l'équipe formatent le code avec \texttt{autopep8} et cela à chaque sauvegarde.

\bigbreak

Un autre sujet qui nous est rapidement apparu essentiel est d'éviter de perdre trop de temps à déboguer. Nous avons donc décidé de créer des logs dans la console à chaque entrée et sortie d'une méthode. En cas de bug, cela nous permet d'identifier rapidement la méthode qui pose un souci et de la corriger. Nous aurions pu chercher à mettre en place un système de log plus perfectionné, mais celui utilisé nous convenait parfaitement.

\bigbreak

Ensuite, concernant les classes pour communiquer avec la base de données ou l'API, nous avons réutilisé et adapté celles qui nous ont été fournies lors des Travaux Pratiques. Après quelques ajustements, cela a très bien fonctionné et nous n'avons pas eu à les modifier par la suite.

\bigbreak

La question suivante était de savoir comment fonctionnait le package \texttt{inquirerPy} que nous devions utiliser pour notre interface avec l'utilisateur. Nous avons été agréablement surpris par la simplicité d'utilisation de cet outil et par toutes les possibilités qui étaient offertes. Nous avons utilisé certaines d'entre elles pour vérifier que les entrées de l'utilisateur correspondaient à nos attentes (entrée non vide, entrée numérique pour le niveau d'un personnage, entrée avec arobase pour une adresse mail).

\bigbreak

Un autre besoin était d'afficher des tableaux de manière lisible et ergonomique. Nous avions découvert lors d'un précédent projet un outil très intéressant : la package \texttt{tabulate} qui répond à ce besoin et nous l'avons donc réutilisé.

\bigbreak

Lors de la mise en place de la base de données, nous avons créé un schéma \texttt{jdr} (pour que tous les objets soient regroupés dans un même schéma), des tables, ainsi que d'un échantillon de données. Cet échantillon est principalement utile pour éviter d'avoir à saisir manuellement des joueurs, des personnages lorsque l'on veut tester notre code python. Nous avons pensé que ce serait utile d'avoir une fonctionnalité qui permet de réinitialiser la base de données et nous l'avons donc mise en place. 
Ainsi, lorsque nous voulions réinitialiser les données, nous avions cette possibilité dans le menu de l'application, ce qui est beaucoup plus simple et rapide que de relancer les scripts de création «~à la main~». Cependant nous avons enlevé cette possibilité dans le livrable final car l'utilisateur ne doit pas avoir accès à cette fonctionnalité.

\bigbreak

Enfin, nous avons jugé intéressant d'utiliser des variables d'environnements globales pour fixer les valeurs de certaines variables qui sont relativement fixes. Nous avons par exemple, créé des variables d'environnement pour fixer le nombre maximum de personnages par joueur, le nombre maximum de joueurs par table et le nombre maximum de tables par séance. De cette manière, si les administrateurs décident de modifier l'un de ces paramètres, ils peuvent facilement le faire en modifiant le fichier \texttt{.env}.



\subsection{Persistance des données}


La \textbf{méthode de persistance} que nous avons choisie est la sauvegarde de nos données dans une base de données. Le système de gestion de base de données relationnelles (SGBD) que nous avons utilisé dans notre projet est PostgreSQL.\\

La couche \textbf{DAO} (Data Access Object), présenté sur le diagramme UML figure \ref{UML_dao} regroupe l'ensemble des classes et méthodes directement liées à la gestion de la persistance de nos données. Elle est lié à la couche de service de notre application. En effet, les fonctionnalités choisies et exécutées par l'utilisateur auront des répercussions plus ou moins significatives sur la modification des données. Cette couche est également indirectement liée aux objets métiers, en effet c'est à partir des attributs des classes de nos objets metiers que les données sont extraites afin d'être communiquées à notre SGBD.
Les spécificités et propriétés des classes de la DAO notamment son héritage avec la classe DBconnection et le patron de conception choisie dans l'implémentation de cette classe sont explicités dans la section précédentes 3.1.

La couche DAO sera constituée des classes suivantes :

\begin{itemize}
    \item \texttt{JoueurDao}~: Celle-ci se chargera de la gestion des données liées aux joueurs.
    
    \item \texttt{PersonnageDao}~: Celle-ci se chargera de la gestion des données liées aux personnages.
    
    \item \texttt{MessageDao}~: Celle-ci chargera de la gestion des données liées à la messagerie des joueurs.
 
    \item \texttt{TableJeuDao}~: Celle-ci se chargera de la gestion des données liées aux tables de jeu.
    
    \item \texttt{MaitreJeuDao}~: Celle-ci se chargera de la gestion des données liées au joueur particulier qu'est le maître du jeu.
    
    \item \texttt{SeanceDao}~: Celle-ci se chargera de la gestion des données liées à la séance.

\end{itemize}

\begin{figure}[H]
    \label{UML_dao}
    \centering
    \includegraphics[angle=90,height=0.88\textheight]{UML_diagrammes/dao.png}
\end{figure}

Le diagramme de base de données est présenté dans la figure \ref{UML_bdd}. Celui-ci s'accorde rigoureusement avec les classes de la couche DAO. Nous avons cependant omis de rajouter la table de données relative aux informations de l'administrateur car non réellement pertinente, l'application ne permet aucune modification des données de l'administateur. Notre base de données se compose des tables et relations suivantes (cf \ref{UML_bdd} pour les relations) :  

\begin{itemize}
    \item \texttt{table\_jeu}~: Cette table de données représente une table de jeu. Clé primaire~: (\texttt{id\_table})
    
    \item \texttt{table\_personnage}~: Elle fait le lien entre les tables \texttt{personnage} et \texttt{table\_jeu}. Clé primaire~: (\texttt{id\_table, id\_personnage}). Cela permet de dire quels personnages sont joués à une Table de Jeu.
    
    \item \texttt{joueur}~: Cette table de données se chargera de la gestion des données liées aux joueurs. Clé primaire~: \texttt{id\_joueur}
 
    \item \texttt{message}~: Cette table contient les messages de notification reçus par les joueurs ou les administrateurs. Clé primaire~: \texttt{id\_message}
    
    \item \texttt{personnage}~: Elle regroupe les personnages joués par les joueurs. Clé primaire~: \texttt{id\_personnage}
    
    \item \texttt{seance}~: Cette table contient les données concernant les séances. Clé primaire~: \texttt{id\_seance}

\end{itemize}


\begin{figure}[H]
    \caption{\textbf{Diagramme de Base de données}}
    \label{UML_bdd}
    \centering
    \includegraphics[height=0.4\textheight]{UML_diagrammes/bdd.png}
\end{figure}


Chaque table se définit par sa clé primaire qui peut être un singleton, ou un couple d'attributs. Cette clé permet d'identifier de manière unique chaque enregistrement (observation) d'une table. Nos tables peuvent comporter une ou plusieurs clés étrangères afin d'établir des relations entre les tables comportant des attributs communs.



%-------------------------------------------------------------------------------
% Section 4
%-------------------------------------------------------------------------------

\newpage
\section{Fonctionnalités de l'application}

Un utilisateur de l'application peut être soit un administrateur soit un joueur. Un administrateur se différencie des joueurs puisqu'il est l'organisateur de la conférence. Il a donc un rôle de modération et de planification des séances de jeu de rôle et dispose de fonctionnalités propres.

Quant au joueur, il peut être à la fois joueur (disposant de ses personnages) sur une séance et maître du jeu sur une autre. Bien évidemment, un joueur ne peut pas être simple joueur et maître du jeu lors d’une même séance. Cet aspect permet au joueur d’une séance à l’autre de changer de statut sans avoir besoin de créer un nouveau compte (ainsi un utilisateur n’a besoin que d’un seul compte joueur. Le joueur dispose lui aussi de fonctionnalités qui lui sont propres.



\subsection{Fonctionnalités Utilisateur}

On désigne par «~Utilisateur~» toute personne lançant l'application. L'Utilisateur peut aussi bien être un acteur déclaré de la convention (Joueur, Maître du Jeu, Administrateur), qu'une personne intéressée ou un simple passant.\\

L'acteur déclaré peut entrer dans l'application avec l'option \texttt{S'authentifier}. Il accèdera alors aux fonctionnalités liées à son statut après avoir renseigné son identifiant.\\

La personne intéressée peut s'inscrire à la convention avec l'option \texttt{S'inscrire}. Après avoir renseigné quelques informations, son compte sera créé et elle pourra alors accéder à son profil en s'authentifiant.\\

Enfin, l'option \texttt{Quitter} permet à quiconque de fermer l'application.\\



\subsection{Fonctionnalités communes aux Joueur, Maître du Jeu et Administrateur}

Toute personne s'étant identifiée sur l'application a la possibilité de consulter ses messages ou de se déconnecter.\\

La consultation des messages permet aux Joueurs et Maîtres du Jeu de savoir si une modification est intervenue dans leur emploi du temps. Elle permet aussi à l'Administrateur de savoir si un changement du côté des Joueurs ou Maîtres du jeu a des conséquences sur le déroulement de la convention qui nécessitent son intervention. Pour faciliter l'organisation de chacun, le nombre de nouveaux messages est indiqué lors de la connexion à l'application.\\

La déconnexion permet de sortir de l'application et de redevenir simple Utilisateur.



\subsection{Fonctionnalités spécifiques à l'Administrateur} 

Les fonctionnalités spécifiques à l'Administrateur concernent la gestion de la convention:
\begin{itemize}
\item{gestion des comptes}
\item{gestion des tables\\}
\end{itemize}

La gestion des comptes consiste à avoir la possibilité de supprimer le compte d'un Joueur en cas de comportement inapproprié. Cela pourrait s'avérer utile par la suite si un système de chat ou de messagerie accessible aux participants devait être implémenté dans l'application (actuellement la messagerie est automatique).\\

La gestion des tables consiste à ajouter/supprimer des tables en fonction de leur taux d'occupation et à intervenir sur la répartition des Joueurs et Maîtres du Jeu. Elle nécessite de pouvoir disposer d'un aperçu d'ensemble de la convention, i.e. de voir, pour chaque séance, l'ensemble des tables disponibles avec les Joueurs et Maîtres du jeu concernés. Si l'Administrateur constate qu'une séance a toutes ses tables suffisamment occupées, il a la possibilité d'ajouter une table pour permettre à davantage de personnes de s'inscrire sur la séance en question. A contrario, si les tables d'une séance sont peu occupées, il peut les réorganiser en déplaçant un personnage (et donc le joueur correspondant) ou un Maître du Jeu sur une autre table, voire supprimer une table vide. Les actions de l'Administrateur qui impactent l'emploi du temps d'un Joueur ou Maître du Jeu entrainent automatiquement l'envoi d'un message à la personne concernée.\\

Chacune de ces fonctionnalités comporte plusieurs étapes. A titre d'exemple, nous allons voir le déplacement d'un personnage. Rappelons que l'Administrateur a au préalable visualisé l'aperçu d'ensemble de la convention et qu'il sait par conséquent quelles tables posent problème avant de lancer cette fonctionnalité. 
\begin{itemize}
    \item Etape 1~: une liste des tables occupées s'affiche, mentionnant la séance et le scénario. L'Administrateur peut repérer la table problématique dans cette liste.
    \item Etape 2~: il voit la liste des personnages incarnés sur cette table et doit en choisir un.
    \item Etape 3~: la liste des tables de la même séance ayant des places disponibles s'affiche. L'Administrateur a le choix entre les tables de la liste et l'option «~Aucune table~», signifiant que le Joueur n'a plus de partie programmée sur la séance.
    \item Etape 4~: une confirmation est demandée pour lancer la procédure.
\end{itemize}



\subsection{Fonctionnalités spécifiques au Joueur} 

Les fonctionnalités accessibles au Joueur doivent lui permettre d'organiser sa participation à la convention.\\

Le Joueur qui le souhaite peut accéder au statut de Maître du Jeu grâce à l'option \texttt{Devenir Maître du Jeu}. Après confirmation de son choix, l'option \texttt{Devenir Maître du Jeu} est remplacée par \texttt{Accéder au menu Maître du Jeu} qui lui donne l'accès aux fonctionnalités spécifiques du Maître du Jeu.\\

L'option \texttt{Voir programme} lui permet de visualiser rapidement l'ensemble des tables sur lesquelles il est inscrit en tant que Joueur ou en tant que Maître du Jeu. Un Joueur ayant la double casquette a ainsi accès à son programme complet en un seul clic.\\

Le Joueur peut gérer ses personnages, grâce aux options \texttt{Créer un personnage} (dans la limite de 3 personnages par Joueur), \texttt{Supprimer un personnage} et \texttt{Lister ses personnages}, qui lui donne un résumé des caractéristiques de chaque personnage.\\

Il peut aussi décider de \texttt{Rejoindre une table} pour y participer en tant que Joueur, \texttt{Quitter une table} s'il ne souhaite plus participer à une table en tant que Joueur, voire de \texttt{Supprimer son compte} s'il estime ne plus pouvoir ou vouloir participer à la convention.



\subsection{Fonctionnalités spécifiques au MJ} 

Un Joueur inscrit comme Maître du Jeu accède en premier lieu à la fonctionnalité lui permettant de \texttt{Gérer une table}, en proposant un scénario, ce qui a pour effet de rendre la table disponible à l'inscription pour les Joueurs.\\

Il peut par la suite à tout moment consulter l'occupation des tables qu'il gère grâce à l'option \texttt{voir les Tables gérées}, lui procurant les caractéristiques de chaque personnage inscrit à ses tables.\\

Enfin il peut, en cas de nécessité, décider de \texttt{Résilier une table}. L'Administrateur en est averti par un message et doit agir pour proposer, dans la mesure du possible, une solution aux Joueurs qui s'étaient inscrits sur cette table.\\




\subsection{Focus sur une fonctionnalité : Résilier une table}

Toutes les fonctionnalités ci-dessus doivent être coordonnées entre les fonctions des différentes couches pour être complètes. Voici un exemple du flux de travail de l'application lors du lancement de la fonctionnalité \texttt{Résilier une table} du Maître du Jeu.\\

Lorsque le Maître du Jeu sélectionne \texttt{Résilier une table}, l'application commence par se diriger vers la vue \texttt{ResilierTableVue}. Aussitôt l'application appelle la méthode «~service~» \texttt{lister\_tables()} du module \texttt{MaitreJeuService} de la couche Service pour trouver toutes les tables sur lesquelles l'utilisateur s'est enregistré comme MJ. Cette méthode «~service~» appelle la méthode «~dao~» \texttt{lister\_tables\_mj()} du module \texttt{MaitreJeuDao} pour obtenir la liste via la base de données. Les tables sont ensuite rangées dans l'ordre chronologique grâce au numéro de séance qui fait partie de leurs attributs (1 pour Samedi matin, etc). Pour que l'affichage soit clair, nous avons préféré afficher le descriptif de la séance et le scénario. L'obtention du descriptif se fait grâce à un dictionnaire importé via la méthode «~dao~» \texttt{lister\_toutes()} du module \texttt{SeanceDao}.\\

Si le Maître du Jeu n'a pas de tables qui peuvent être résiliées, aucune liste ne s'affiche, il obtient le message «~Vous ne gérez pas de table actuellement~» et revient à la vue \texttt{MaitreJeuMenuVue}.\\

S'il a des tables à gérer, la liste s'affiche. Le Maître du Jeu peut changer d'avis et sélectionner «~Non, finalement j'ai changé d'avis~»~: aucune table n'est résiliée et il revient à la vue \texttt{MaitreJeuMenuVue}.\\

Il peut aussi choisir une table dans la liste et confirmer son choix. Une fois que le Maître du Jeu a confirmé la résiliation, l'application appelle la méthode «~service~» \texttt{resilier\_table()} du module \texttt{MaitreJeuService}, où \texttt{resilier\_table()} est programmée pour terminer la résiliation de la table de jeu et pour envoyer une notification à l'administrateur et aux joueurs de la table. Cette méthode «~service~» appelle les méthodes «~dao~» \texttt{lister()} du module \texttt{TableJeuDao} pour localiser et instancier la table à supprimer et \texttt{joueurs\_assis()} du module \texttt{TableJeuDao} pour trouver les joueurs à la table. Ensuite elle appelle la méthode «~dao~» resilier\_table du module \texttt{MaitreJeuDao} pour supprimer la table dans la base de données. Enfin, la méthode «~dao~» \texttt{creer()} du module \texttt{MessageDao} inscrit dans la base de données un message de résiliation à l'administrateur et aux joueurs concernés, qu'ils pourront lire par la suite.\\

Une fois la résiliation effectuée, le maître du jeu revient à la vue \texttt{MaitreJeuMenuVue} et reçoit un message confirmant son départ de la table.


%-------------------------------------------------------------------------------
% Section 5
%-------------------------------------------------------------------------------

\newpage
\section{Guide d'utilisation}

Notre application est utilisable par n'importe quel utilisateur (qu’il soit joueur ou administrateur). Il lui suffit de respecter certaines consignes, nécessaires au bon fonctionnement de l’application, que nous allons énoncer par la suite. 

\subsection{Installation de l'application}
Le lancement de l'application n'est pas immédiat, il faut au préalable suivre un protocole de mise en place et d’installation. \\

Dans un premier temps l’utilisateur doit cloner le code de l’application afin qu’il puisse l’utiliser sur son ordinateur. Il s’agit de créer son dépôt local à partir du code existant sur un dépôt distant hébergé, dans notre cas, par github.
Pour cela, il doit ouvrir un terminal dans VS Code dans lequel il renseignera l’instruction suivante : \texttt{git clone git@github.com:ludo2ne/projet-info-2A.git} \\

Ensuite, de nombreux packages sont nécessaires à l’architecture du code et au bon fonctionnement de l’application. Il faut donc nécessairement les installer. Ainsi l'utilisateur doit installer les packages contenus dans le fichier requirements.txt. Il liste ligne par ligne les packages suivants~: \texttt{autopep8, inquirerPy, psycopg2-bina, ry, tabulate, regex, pyfiglet, mock, python-dotenv}. Pour réaliser l’installation de tous ces packages, l’utilisateur doit ouvrir un terminal et lancer la commande suivante~: \texttt{pip install -r requirements.txt} \\

Pour utiliser l'application il faut également créer une base de données afin de sauvegarder les contenus dans des tables. Une fois la base de données créée, un script SQL nommé \texttt{init\_db.sql} permet de créer le schéma ainsi que les tables. Un second script nommé \texttt{pop\_db.sql} insére un échantillon de données dans les tables. \\

Enfin il est également nécessaire que l'utilisateur crée un fichier \texttt{.env} contenant les informations suivantes~: 

\begin{figure}[h]
\centering
\includegraphics[width=9cm]{envfile.PNG}
\caption{
Contenu du fichier \texttt{.env}}
\end{figure}



\newpage

\subsection{Lancement de l'application}

Une fois les manipulations précédentes réalisées, l'application pourra être lancée. L'utilisateur doit ouvrir un terminal et lancer l’instruction suivante~: \texttt{python src/main.py}. S’il souhaite vérifier que les tests unitaires sont valides, il peut lancer tous les tests à l'aide de la commande suivante~:
\texttt{python src/run\_all\_tests.py} \\

Lors du lancement de l'application, l'utilisateur peut choisir de se créer un compte avec son pseudo, son pseudo et son mail. Ce pseudo lui servira d’authentification pour accéder à son menu de Joueur où il pourra s’inscrire créer/supprimer des personnages et rejoindre/quitter des tables et bien d’autres fonctionnalités. Il peut aussi avec son compte Joueur, devenir Maître du jeu et accéder au menu Maître du jeu, où il peut créer des scénarios et s’inscrire à des tables non plus en tant que Joueur, mais en tant que Maître du jeu. A chaque séance il peut décider de prendre l’un des deux rôles.\\

Si l'utilisateur est un Administrateur, il peut se connecter en tant qu’Administrateur en renseignant le pseudo \texttt{admin}. Il accédera alors à une grande liste de fonctionnalités de modération de la conférence de jeu de rôle. Il peut par exemple supprimer un joueur, supprimer/ajouter des tables.





%-------------------------------------------------------------------------------
% Section 6
%-------------------------------------------------------------------------------

\newpage
\section{Perspectives d'amélioration de l'application}

\subsection{Fonctionnalités et paramètres potentiellement améliorables dans l'application}

Lors de l'examen du code, nous avons envisagé la possibilité d'optimiser les fonctionnalités pour rendre l'application plus fluide et plus agréable pour l'utilisateur, mais en raison des contraintes de temps, nous n'avons pas été en mesure de les améliorer.\\

Tout d'abord, en ce qui concerne le nombre de séances, nous n'en avons actuellement que 4, étant donné que les jeux ne se déroulent que le matin et l'après-midi du week-end. Si nous voulions permettre à notre application dé gérer des événements hebdomadaires, cela pourrait se faire en modifiant le nombre maximal de séances.\\

De plus, actuellement, les utilisateurs se connectent directement en utilisant leur pseudo et il n'existe pas de mot de passe. Néanmoins, l'ajout d'un mot de passe pour compléter l'identification est particulièrement important pour l'administrateur du jeu, dont le pseudo est connu pour être «~admin~», ce qui ne fournit pas une sécurité suffisante, nous avons besoin donc d'améliorer la fonction «~S'authentifier~» en ajoutant un mot de passe.






\subsection{Fonctionnalités facultatives pour une meilleure organisation}

Au fur et à mesure que nous avancions dans le code de l'application, nous nous rendions compte que certaines fonctionnalités pourraient être intéressantes et également utiles. Nous n'avons pas eu le temps de mettre en place ces fonctionnalités additionnelles, mais nous pensons qu'elles pourraient faire l'objet de demandes d'évolution sur notre application.

\bigbreak

Une des premières possibilités à laquelle nous avons pensé serait d'autoriser l'utilisateur à modifier ses informations personnelles. Actuellement, le joueur saisit ses informations lors de l'inscription et ne peut plus les modifier. Il peut cependant supprimer son compte et le recréer s'il en a la volonté. Ainsi, nous aurions pu ajouter une fonctionnalité pour autoriser le joueur à modifier ses informations personnelles.

\bigbreak

Lorsqu'un joueur souhaite rejoindre une table de jeu, on lui demande de choisir un personnage parmi ceux qu'il a créé pour jouer. Par contre, il ne peut pas voir quels sont les autres personnages déjà présents à la table et cela pourrait avoir un impact sur son choix. Imaginons qu'à une table de jeu, il y ait déjà deux Magiciens, et que le joueur souhaite rejoindre cette table avec son personnage qui est également de type Magicien. Peut-être qu'en sachant les personnages déjà présents à la table, notre joueur aurait choisi un autre personnage.

\bigbreak

Dans notre application, nous avons utilisé des messages pour avertir les joueurs ou administrateurs de certaines actions les impactant. Nous pourrions imaginer étendre ce système de message pour autoriser les administrateurs à communiquer à tout le monde, les Maîtres du jeu à envoyer des messages aux joueurs de leurs tables et éventuellement de donner la possibilité à tous les joueurs d'échanger des messages. Même si ce dernier point commencerait à complexifier sérieusement notre application.



%-------------------------------------------------------------------------------
% Conclusion
%-------------------------------------------------------------------------------

\newpage
\section*{Conclusion}
\addcontentsline{toc}{section}{Conclusion}

L'objectif de ce projet était de réaliser une application de gestion des tables pour une conférence de jeux de rôles. Il nous a permis de voir les différentes étapes de conception et de réalisation d'une application. Nous avons pu, à travers ce projet, mettre en œuvre les connaissances acquises pendant les cours et les travaux pratiques (modélisation, développement, programmation en couches...). Le sujet était à la fois intéressant, simple et pédagogique. Durant la phase d'analyse, nous sommes rapidement arrivés à un consensus sur la manière de modéliser notre future application. Cette phase a été très importante, car elle nous a permis, à la fois d'avoir tous le même niveau de connaissance de l'application, et elle nous a également permis de clarifier la manière dont nous allions coder. L’application ressemble en très grande partie à ce que nous avions conçu durant cette phase d’analyse. Nous avons tout de même intégré quelques ajustements et modifications mineures.

\bigbreak

La phase de développement s’est faite principalement en deux étapes. Une première version « bêta zéro » comprenant une unique fonctionnalité a été développée. Le but était de réaliser une preuve de concept (POC) pour vérifier que nous avions une application qui fonctionne pour cet unique service. Nous avons ainsi dans un premier temps codé cette version, incluant toute l’architecture de l’application (base de données, interface…). Cela nous a été très utile par la suite, car à partir de cette première version, le développement des autres fonctionnalités a été beaucoup plus rapide. De plus, nous avons pu facilement paralléliser et nous répartir les développements. Ainsi, la phase de développement a été assez rapide pendant les trois jours dédiés et nous avons pu atteindre nos objectifs.

\bigbreak

L'application finale est opérationnelle et utilisable. Nous avons essayé de la rendre aussi intuitive et ergonomique que possible. Cependant, nous avons conscience que des améliorations peuvent être apportées, mais les délais très courts de ce projet nous ont incités à nous concentrer sur l'essentiel. Nous avons donc le plaisir de vous laisser découvrir notre application.





\newpage

\section{Notes personnelles}

\textbf{\Large Note de Hugo Wispelaere}

Le projet d’informatique a été une véritable découverte pour moi à la différence de celui de première année ; en effet il m’a permis de davantage coder et d’acquérir de nouvelles compétences en programmation et de découvrir un autre schéma de structure de code : la programmation en couches, alors que l’année précédente j’étais davantage chargé de la rédaction des rapports.

\bigbreak
\textbf{ Ma participation effective au projet : }

Lors de l’analyse des besoins et la conception de l’architecture de notre projet, je n’ai pas été très utile dans la conception des diagrammes, car d'autre membres étaient bien plus expérimentés et efficaces. En revanche, je proposais quelques alternatives qui me semblaient pertinentes et judicieuses quant aux choix de certaines classes.  J’avais donc un rôle plus en retrait d’analyse, de questionnement de ce que les autres membres du groupe avaient imaginés. J'essayais aussi avec les autres membres de concilier les avis de tout le monde quand il y avait des avis différents. Il s’agissait de peser le pour et le contre de chaque idée des membres du groupe et de prendre la meilleure solution (et souvent la plus simple à mettre en place). \\ 

Lors de la programmation, j’étais au début très peu à l’aise mais ayant eu un exemple de classe de vue concret de Ludovic, j’ai pu moi-même coder de nombreuses classes de vue (et donc en même temps des méthodes de classes plus compliquées). \\ 

Enfin, lors de la rédaction du rapport, nous avons séparé la rédaction à part égale. Je me suis donc occupé de la rédaction de plusieurs sous-parties comme le lancement de l’application ou encore la description des objets métiers.

\bigbreak
\textbf{ Mon ressenti sur le projet, comment je l’ai vécu :  }

Le projet me semblait au premier abord très compliqué. J’étais un peu perdu avec le schéma logique des choses. Lorsque j’ai vu les classes s’accumuler dans le diagramme de classes et le nombre de fonctionnalités à implémenter je me suis vite remis en question. Je me demandais si j’allais réussir à comprendre comment articuler le code. Par ailleurs, l’implémentation du code devait se faire avec une structure en couche que je ne connaissais absolument pas avant le cours dédié à cette architecture. Cependant, les membres les plus expérimentés dans le domaine m’ont expliqué pas à pas comment faire. Par exemple, je n'avais aucune idée de comment l’application allait pouvoir s’afficher dans le terminal de VS Code. Mais avec le temps et les exemples déjà mis en place j’ai compris l’architecture de l’application. J’ai donc finalement compris le système de vue, de services et de persistance de données au fur et à mesure. Au final le projet a été très enrichissant en termes d’expérience et de compétences en programmation orientée objet. En effet le groupe de 5 a permis de découvrir la manière de réaliser une tâche et prendre exemple sur eux si je trouvais leur manière de faire plus optimisée que la mienne. 

\bigbreak
\textbf{ Ce que je retiens du projet :   }

Ce que je retiens de ce projet de 3 mois, c’est qu’il ne faut pas commencer avec des à priori. Je suis parti du principe que je ne serais pas capable de participer au code de l’application. Et pourtant j’ai bien contribué au développement de ce dernier. Je retiens aussi qu’il ne faut pas chercher à avoir la perfection tout de suite, que ça soit pour le diagramme de classe ou encore le code. En effet, l'amélioration de ces derniers se fait au fur et à mesure, on ne peut pas penser à tout instantanément, il faut un temps d'adaptation et de manipulation du sujet. Enfin une chose que je retiens à la fin de ce projet réside dans le fait qu’il existe toujours des améliorations possibles dans un projet. Il est toujours possible d’ajouter des fonctionnalités facultatives qui sont plus ou moins intéressantes pour un joueur, mais aussi des améliorations en ce qui concerne l’optimisation du code (afin que l’application tourne plus vite par exemple).

\newpage



\textbf{\Large Note de Ludovic Deneuville}

\bigbreak

J'ai abordé ce projet avec un certain enthousiasme, car j'aime beaucoup les projets informatiques. À notre première session, j'étais assez rassuré quant à la composition de notre équipe. L'année précédente, j'avais vécu une expérience compliquée lors du projet stat de 1A, et je souhaitais éviter que cela se reproduise. Après un bref tour de table des compétences et appétences de chacun, tout le monde était motivé pour développer, c'était une excellente nouvelle.

\bigbreak

Lors de la répartition des rôles, j'ai vite compris que personne ne serait candidat pour être chef de projet et que ce rôle allait me revenir. Ayant déjà expérimenté ce rôle dans ma vie professionnelle, et lors de chacun de mes projets ENSAI, ce n'était pas un rôle que je souhaitais particulièrement, mais après tout pourquoi pas, chaque projet est différent et toute nouvelle expérience est bonne à prendre.

\bigbreak

Mon point fort en tant que chef de projet est l'organisation. Je sais très bien gérer, lister les tâches, suivre l'avancement... C'est vraiment une partie que je fais avec plaisir. Mon point faible, c'est le management. Même si je ne me considère pas comme le grand chef, mon rôle implique inévitablement de motiver l'équipe pour que le projet avance bien, ce que je pense n'avoir réussi que partiellement. De toute façon ce n'est pas facile d'avancer tous ensemble alors que nous avons une charge de travail très importante à côté.

\bigbreak

Concernant la partie analyse, ça faisait partie de mon métier avant de venir à l'ENSAI. J'ai essayé de laisser tout le monde participer, ce qui a été le cas. Après, parfois, j'ai dû mettre un veto sur certains choix qui me paraissaient trop compliqués à mettre en œuvre. Parfois aussi, pour essayer d'éviter d'être trop directif, j'ai su laisser les autres décider lorsque je n'étais pas assez convaincant, même si j'étais sûr que lors de la mise en pratique cela allait coincer. Après cela concernait généralement des choix mineurs qui ne nous ont pas fait perdre beaucoup de temps par la suite. En-tout-cas, je pense que nous avions fourni un travail sérieux d'analyse.

\bigbreak

Ensuite pour la partie programmation, comme dit plus haut, dans l'équipe, tout le monde veut développer. C'est une très bonne chose, par contre, je souhaitais faire en sorte que tout le monde aille dans la même direction. La première étape qui m'a paru indispensable et que je conseille plus que fortement à nos successeurs est de coder une fonctionnalité basique utilisant toutes les couches. Aussi, ayant mis un certain temps à comprendre l'intérêt de la programmation en couches, je me doutais que cela ne serait pas simple pour mes coéquipiers et que je me devais de débroussailler le terrain. De plus, ne pratiquant le Python que depuis peu, cela m'a pris un peu de temps, car cela implique de mettre en place de nombreuses choses, par exemple créer et remplir une base de données. Même si ce ne fut pas simple, j'étais satisfait d'avoir assez vite une v0 qui tourne.

\bigbreak

Lors de la phase de développement, tout est allé assez vite. J'ai passé un peu de temps à faire du pair programming et tout a bien avancé, en particulier lors des trois jours dédiés. La période suivante fut plus compliquée car rythmée par des examens et donc c'était compliqué de remotiver l'équipe pour terminer le projet. Actuellement, nous sommes en pleine rédaction du rapport et soyons honnêtes, ce n'est pas la partie qui nous plaît le plus. En-tout-cas, je suis assez satisfait de la manière dont s'est déroulé ce projet, merci à toute l'équipe !



\newpage

\textbf{\Large Note de Jean-François Parriaud}\\

J'ai commencé à apprendre le langage Python pour les besoins de mon précédent métier il y a deux ou trois ans. Le projet d’informatique était pour moi à la fois source d'appréhension et d'excitation. Mon excitation venait du fait que j'aime coder, et qu'un projet consistant n'était pas pour me déplaire. L'appréhension venait du fait que la programmation orientée objet était nouvelle pour moi, ainsi que les logiciels utilisés à l'ENSAI, et que j'ai toujours programmé seul jusqu'ici.

\bigbreak
\textbf{ Ma participation effective au projet : }

Lors de la phase de conception de l’architecture de notre projet,
j'ai réfléchi de mon côté au diagramme de classes et au diagramme de base de données pour pouvoir participer à la discussion. C'était l'occasion de réinvestir des notions que j'estimais avoir assez bien comprises et j'ai pu participer activement à la discussion. La position du Maître du Jeu est vite apparue comme problématique.\\

Lorsque la notion de couches a été abordée en TP et qu'il fallait voir comment l'implémenter dans le projet, j'étais plus en retrait: je n'étais pas à l'aise avec cette notion. Lorsque notre tutrice nous a par la suite parlé de répartition horizontale ou verticale des tâches pour la programmation, je pensais être insuffisamment préparé pour les vues et la DAO, et plutôt me rabattre sur les services. Autant dire que j'excluais la répartition verticale...\\

Cependant Ludovic avait dans l'idée que chacun code au moins une fonctionnalité de A à Z, c-à-d de la couche vue à la couche dao. Il a ainsi attribué une fonctionnalité à chacun. La mienne était "Supprimer un personnage". Ludovic avait déjà créé toute l'architecture et codé une fonctionnalité complète. Dans un premier temps, j'ai navigué dans le code afin de comprendre son fonctionnement, puis je me suis lancé en m'inspirant de son travail. Ca a été laborieux, mais en y allant pas à pas, j'ai pu aller seul au bout de la fonctionnalité et j'étais rassuré. Par la suite, je n'ai plus eu d'appréhension à l'idée de coder une fonctionnalité de bout en bout et je me suis spécialisé dans les suppressions et les affichages.\\

Lors de la rédaction du rapport, je me suis occupé de la partie fonctionnalités et suis membre du comité de relecture. En parallèle j'ai continué de tester l'application pour détecter des bugs ou des problèmes d'ergonomie.\\

\bigbreak
\textbf{ Mon ressenti sur le projet, comment je l’ai vécu :  }

Les premières semaines après mon arrivée à l'ENSAI, j'avais l'impression d'avoir toujours un train de retard: messages non lus, fonctionnement du réseau à comprendre, des applications et des langages nouveaux (R, SAS). Je craignais en plus d'avoir du mal à m'intégrer dans un travail d'équipe avec des élèves qui se connaissaient déjà depuis un an. Finalement l'intégration s'est bien passée, l'ambiance dans l'équipe était bonne, chacun s'est investi à sa façon.\\
Nous avons alterné le travail individuel et les phases de concertation, échangé sur Discord pour nous tenir au courant du travail de chacun. Cela permettait d'être bien concentré sur sa tâche, tout en sachant pouvoir compter sur les autres en cas de besoin, et de pouvoir suivre l'avancement global des travaux. De plus les entretiens réguliers avec notre tutrice nous ont permis de savoir si nos idées tenaient la route et si nous étions dans le bon tempo.\\

\bigbreak
\textbf{ Ce que je retiens du projet :   }

Un projet complexe est moins linéaire qu'un programme individuel. Le fait d'être plusieurs sur le projet a été très utile, pour confronter les points de vue et utiliser au mieux les appétences de chacun. Nous avons parfois dû remettre en cause des idées trop simplistes, rajouter des classes, des méthodes non prévues initialement. Avoir une personne qui teste différente de celle qui code permet aussi d'apporter des améliorations notables sur l'ergonomie. Avec le recul de cette première expérience, j'ai conscience qu'avec une équipe soudée, on peut se permettre de prendre en charge un projet qui serait inenvisageable seul.\\

A titre personnel, j'ai pris davantage confiance en mes capacités d'adaptation à un nouvel environnement et j'ai pu confirmer mon goût pour le code.



\newpage
\textbf{\Large Note de Banruo Zhang}

Je suis maintenant dans ma deuxième année d'étude à l'ENSAI et après la première année d'étude et l'affinement de mes compétences sur des projets, j'avais déjà une compréhension de la création d'applications. Puis, avec l'ajout du cours Compléments d'informatique, nous avons introduit le concept de nouvelle architecture d'application dans notre projet et avons commencé un nouveau voyage de programmation.

\bigbreak
\textbf{ Ma participation effective au projet : }

Tout d'abord, au début du projet, étant donné le manque de familiarité avec la nouvelle idée de l'architecture d'application et l'écart entre les vacances d'été, j'ai eu un sentiment de déconnexion. Consciente que je devais éventuellement quitter ma zone de confort, j'ai passé plus de temps au début à revoir les connaissances et à comprendre le nouveau concept. Ce décalage a également signifié que je n'ai pas beaucoup contribué au processus de création de diagrammes et de classes. Mais grâce à la patience des membres du groupe qui m'ont aidé à comprendre rapidement, j'ai pu prendre en charge la section couche Vue lors de la rédaction du dossier d'analyse.\\

Comme je l'ai mentionné précédemment, le nouveau concept d'architecture, où nous avons différentes couches, et en particulier le concept de couche Vue et les classes correspondant , m'a fait hésiter dans le développement du code, et la nécessité de revoir les connaissances théoriques à plusieurs reprises. Toutefois, j'ai heureusement pu terminer la rédaction des fonctionnalités pour les différents couches après discussion et avec l'aide des membres d'équipe.\\

Quant à la rédaction du rapport final, nous avons chacun choisi certaines parties pour en être les auteurs principaux, selon nos propres souhaits, tout en relisant et en éditant les autres. Ma tâche principale consistait à décrire les couches, une fonctionnalité détaillée de A à Z, etc.\\

\bigbreak
\textbf{ Mon ressenti sur le projet, comment je l’ai vécu :  }\\
J'ai eu l'impression que l'ensemble du projet avançait de manière lâche et serrée. Bien que j'aie pris plus de temps au début du projet pour comprendre la nouvelle structure, je ne me suis pas sentie trop sous pression ni complètement détendue. En même temps, les membres de mon équipe étaient si actifs, en particulier notre chef de projet, que j'avais moins l'occasion de jouer le rôle de Maître du temps. Dans l'ensemble, je pense que c'était l'un des projets les mieux rythmés auxquels j'ai participé.\\

\bigbreak
\textbf{ Ce que je retiens du projet :   }\\
Premièrement, en ce qui concerne le suivi du projet, notre chef de projet, Ludovic, nous a fait découvrir une nouvelle façon de faire : la création d'un fichier HackMD qui recense les tâches à effectuer et celles qui ont été réalisées à chaque étape du projet. Nous marquons les tâches dont chaque membre est responsable, ce qui permet d'éviter les doublons et de motiver les membres à travailler sur ces tâches. C'était un moyen efficace et flexible de suivre le processus et je l'essaierai sur d'autres projets à l'avenir. D'autre part, le projet a également mis l'accent sur le développement de la pensée divergente, car tant dans la mise en place de l'application que dans la relecture du code, je trouvais toujours des idées auxquelles il était difficile de penser, et c'est la première fois que j'ai appris que la programmation est en fait un sujet complet qui nécessite non seulement une pensée logique mais aussi une pensée divergente pour parvenir à une structure. 












\newpage
\textbf{\Large Note de Jason Torres}

Bien que l'informatique ne m'a pas systématiquement réussi au cours de mon parcours scolaire, j'ai toujours possédé une certaine appétence pour cette discipline. J'avais particulièrement bien apprécié le projet informatique de première année, projet au sein duquel je me suis énormément investi avoir eu le succès escompté. J'ai donc abordé ce projet informatique avec énormément d'engouement. Je l'ai perçu comme une réelle opportunité de progresser de façon significative en programmation mais également d'élargir ma culture en informatique.

\textbf{ Ma participation effective au projet : }
Dès le premier jour ou nous nous sommes réunis pour réfléchir ensemble à l'architecture de notre application, je me suis empressé de traduire nos idées en réalisant des diagrammes correspondant afin d'avoir une perspective et un recul plus intéressants sur notre application. En effet, il me semblait important d'avoir au premier abord une représentation visuelle et physique traduisant l'ensemble de nos idées par des diagrammes afin de nous rendre compte plus facilement des avantages et limites de ceux-ci. 
Je m'investissais beaucoup plus et mettais le maximum de mes efforts lorsque nous décidions de travailler en groupe. À titre personnelle, il m'a semblé bien plus intéressant d'organiser des créneaux de travail en groupe, car cela nous permettait une bien meilleure ergonomie de travail, nous pouvions communiquer et interagir directement avec les autres membres du groupe et leur communiqué nos inquiétudes, problèmes et questionnement.
J'ai pu apporter et communiquer à mes camarades mes idées et propositions concernant le développement de l'application. J'ai également partiellement contribué à la production du code, mais dans une quantité moindre en comparaison à l'apport des cadres du groupe qui avaient déjà un excellent recule et une bonne intuition concernant les concepts informatiques en jeu.

\textbf{ Mon ressenti sur le projet, comment je l’ai vécu :  }
Je me suis fixé l'objectif de pouvoir maîtriser l'intégralité des sujets et concepts informatiques abordés dans ce projet informatique. Malheureusement, en raison d

\textbf{ Ce que je retiens du projet :   }
%-------------------------------------------------------------------------------
% Annexes
%-------------------------------------------------------------------------------

\newgeometry{top=0.5cm, bottom=0.1cm}

\addcontentsline{toc}{section}{Annexes}
\appendix  % On passe aux annexes

\section*{Annexe 1 - Diagramme de classe UML}

\begin{figure}[H]
    \label{UML_classes}
    \centering
    \includegraphics[angle=90,height=0.9\textheight]{UML_diagrammes/diagramme_classe_final.png}
\end{figure}



\restoregeometry


\restoregeometry


\end{document}

